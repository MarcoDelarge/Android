<html><head></head><body><div hidden="" by-polymer-bundler=""><dom-module id="glomo-codi-crypto-dm" assetpath="glomo-codi-crypto-dm/"><template></template><script>var GlomoCodiCryptoDm=/*#__PURE__*/function(_Polymer$mixinBehavio){babelHelpers.inherits(GlomoCodiCryptoDm,_Polymer$mixinBehavio);function GlomoCodiCryptoDm(){babelHelpers.classCallCheck(this,GlomoCodiCryptoDm);return babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(GlomoCodiCryptoDm).apply(this,arguments))}babelHelpers.createClass(GlomoCodiCryptoDm,[{key:"_createKeySource",/*global CryptoJS*/ /**
   * @des Create KeySource
   * @param {Object} - response payload
   */value:function _createKeySource(payload){if(payload&&payload.userData){this.dispatchEvent(new CustomEvent("create-key-source-loader"));this.alias=payload.userData.alias;this.googleId=payload.userData.id;this.checkDigit=payload.userData.dv;this.smsBanxico=payload.userData.sms;this.hardwareId=payload.userData.idh;this.cellPhoneNumber=payload.userData.nc;var shaCodeR=CryptoJS.SHA512(this.smsBanxico).toString(CryptoJS.enc.Hex);this.keySource=CryptoJS.SHA512(shaCodeR+this.hardwareId+this.cellPhoneNumber).toString();this._showGoogleID()}else{this.dispatchEvent(new CustomEvent("create-key-source-loader"));this.dispatchEvent(new CustomEvent("error-get-data-sms"))}}/**
   * @des Decrypt GoogleId
   * @param {Object}
   * @event send-google-id-event
   */},{key:"_showGoogleID",value:function _showGoogleID(){var AESKey=this.keySource.substring(this.googleId0,this.googleId32),ivKey=this.keySource.substring(this.googleId32,this.googleId64),vector=CryptoJS.enc.Hex.parse(ivKey),key=CryptoJS.enc.Hex.parse(AESKey),alias=CryptoJS.AES.decrypt(this.alias,key,{iv:vector}),bytes=CryptoJS.AES.decrypt(this.googleId,key,{iv:vector});this.decryptGoogleId=bytes.toString(CryptoJS.enc.Utf8);this.decryptAlias=alias.toString(CryptoJS.enc.Utf8);this.dispatchEvent(new CustomEvent(""!==this.decryptGoogleId?"send-google-id-event":"error-sms-event",{detail:[this.decryptGoogleId,this.decryptAlias]}))}/**
   * @des Encrypt FirebasId
   * @param {Object}
   */},{key:"_afterFirebase",value:function _afterFirebase(idN){this.idToken=idN.idN;this._createHMac(this.keySource.substring(this.googleId64,this.googleId128))}/**
   * @des Create Hmac for Encrypt Data
   * @param {Object}
   */},{key:"_createHMac",value:function _createHMac(keyHmac){this.toKeyChain=this.toKeyChain===void 0?{}:this.toKeyChain;var checkDigit03=this._addLeftZeros(this.checkDigit.toString(),3),hmacData=this.decryptAlias.toString()+checkDigit03+this.idToken.toString(),hasHex=CryptoJS.enc.Hex.parse(keyHmac),hash=CryptoJS.HmacSHA256(hmacData,hasHex),hashInBase64=CryptoJS.enc.Base64.stringify(hash);this.toKeyChain.hmac=hashInBase64;var pass=this._generatePassword();this._createKeySourceLocal(pass);this._createMaskKeySource(pass)}/**
   * @des Create Hmac Local
   * @param {Object}
   */},{key:"_createKeySourceLocal",value:function _createKeySourceLocal(pass){this.keySourceLocal=CryptoJS.SHA512(pass+this.keySource).toString()}/**
   * @des Encrypt Password
   * @param {Object}
   */},{key:"_createMaskKeySource",value:function _createMaskKeySource(pass){this.clientPassword=CryptoJS.SHA512(pass);var encryptedData=this._XORCipherCustom(this.keySource,this.clientPassword.toString());this.maskKeySource=encryptedData;this._cifraGId()}/**
   * @des Create Password
   * @param {Object}
   */},{key:"_generatePassword",value:function _generatePassword(){var _this=this,lengthCharset=this.generatePasswordValues.charset.length,password=this.generatePasswordValues.lengthPassword;password.forEach(function(item){_this.generatePasswordValues.retVal+=_this.generatePasswordValues.charset.charAt(Math.floor(Math.random()*lengthCharset))});return this.generatePasswordValues.retVal}/**
   * @des Encrypt Google Id
   * @param {Object} - response payload
   * @event return-save-data-event
   */},{key:"_cifraGId",value:function _cifraGId(){var AESKey=this.keySourceLocal.substring(0,32),ivKey=this.keySourceLocal.substring(32,64),vector=CryptoJS.enc.Hex.parse(ivKey),key=CryptoJS.enc.Hex.parse(AESKey);this.cGoogleId=this._cifraAES128(this.decryptGoogleId,key,vector);this.keySource=this._XORCipherCustom(this.clientPassword.toString(),this.maskKeySource.toString());var hmacData=this.decryptAlias.toString()+this._addLeftZeros(this.checkDigit.toString(),3),hasHex=CryptoJS.enc.Hex.parse(this.keySource.substring(this.googleId64,this.googleId128)),hash=CryptoJS.HmacSHA256(hmacData,hasHex),hashInBase64=CryptoJS.enc.Base64.stringify(hash);this.toKeyChain={cGId:this.cGoogleId.toString(),idN:this.idToken.toString(),maKS:this.maskKeySource.toString(),pass:this.clientPassword.toString(),ksl:this.keySourceLocal.toString(),dv:this.checkDigit.toString(),nc:this.cellPhoneNumber.toString(),hmac:this.toKeyChain.hmac,hmacOmission:hashInBase64};this.dispatchEvent(new CustomEvent("return-save-data-event",{detail:this.toKeyChain}))}/*-------Finish Enrollment------------*/ /**
   * @des Generation of folios for collection messages face-to-face
   * @param {Object} now
   */},{key:"_timestampHex",value:function _timestampHex(now){var yearBin=this._addLeftZeros((+now.getUTCFullYear().toString().substring(2)).toString(2),7),monthBin=this._addLeftZeros((+now.getUTCMonth().toString()).toString(2),4),dayBin=this._addLeftZeros((+now.getUTCDay().toString()).toString(2),5),hourBin=this._addLeftZeros((+now.getUTCHours().toString()).toString(2),5),minutsBin=this._addLeftZeros((+now.getUTCMinutes().toString()).toString(2),6),secondsBin=this._addLeftZeros((+now.getUTCSeconds().toString()).toString(2),6),milliseconds=+now.getUTCMilliseconds().toString()%128,milsecondsBin=this._addLeftZeros(milliseconds.toString(2),7),folio=yearBin+monthBin+dayBin+hourBin+minutsBin+secondsBin+milsecondsBin,numberTime=folio.toString(2);return parseInt(numberTime,2).toString(16).toUpperCase()}/**
   * @des Start decryption QR
   * @param {Object}
   * @event decrypt-to-native
   */},{key:"_decryptQrData",value:function _decryptQrData(qrInfo){if(qrInfo&&qrInfo.qrValue&&qrInfo.qrValue.pass){this.qrData=qrInfo.qrValue;this.dispatchEvent(new CustomEvent("decrypt-qr-data-loader"));var now=new Date,hexaTime=this._timestampHex(now);this._requestDecryptionKey(hexaTime)}else{this.dispatchEvent(new CustomEvent("decrypt-to-native",{detail:{}}))}}/**
   * @des Create the request for decryption key for Banxico
   * @param {Object} hexaTime
   * @todo change this request body for BBVA service
   * @event decrypt-to-native
   */},{key:"_requestDecryptionKey",value:function _requestDecryptionKey(hexaTime){this.keySource=this._XORCipherCustom(this.qrData.pass,this.qrData.maKS);var hmacData=this.qrData.ic.IDC+hexaTime.toString()+this.qrData.ic.SER.toString()+this.qrData.v.DEV.split("/")[0].toString()+this._addLeftZeros(this.qrData.v.DEV.split("/")[1].toString(),3)+this.qrData.nc.toString()+this._addLeftZeros(this.qrData.dv.toString(),3)+this.qrData.ic.ENC,hasHex=CryptoJS.enc.Hex.parse(this.keySource.substring(this.googleId64,this.googleId128)),hash=CryptoJS.HmacSHA256(hmacData,hasHex),hashInBase64=CryptoJS.enc.Base64.stringify(hash);this.scfRequest={type:1,sellerPhoneNumber:this.qrData.v.DEV.split("/")[0].toString(),sellerCheckDigit:this.qrData.v.DEV.split("/")[1].toString(),buyerPhoneNumber:this.qrData.nc.toString(),buyerCheckDigit:this.qrData.dv.toString(),chargeMessageIdentifier:this.qrData.ic.IDC+hexaTime,serialCharge:this.qrData.ic.SER.toString(),encryptedChargeInformation:this.qrData.ic.ENC,hmac:hashInBase64};this.dispatchEvent(new CustomEvent("decrypt-to-native",{detail:this.scfRequest}))}/**
   * @des Decrypt QR data
   * @param {Object}
   * @event decrypt-qr-to-native-event
   */},{key:"_decryptPaymentData",value:function _decryptPaymentData(cveDecoded){if(cveDecoded&&cveDecoded.keyValue&&cveDecoded.keyValue.pass){this.keySource=this._XORCipherCustom(cveDecoded.keyValue.pass,cveDecoded.keyValue.maKS);var symmetricKeys=CryptoJS.SHA512(this.scfRequest.chargeMessageIdentifier+this.keySource+this.scfRequest.serialCharge.toString()).toString(CryptoJS.enc.Hex),byteArray=this._XORCipherCustom(cveDecoded.keyValue.key,symmetricKeys),AESKey=byteArray.substring(this.googleId0,this.googleId32),ivKey=byteArray.substring(this.googleId32,this.googleId64),vector=CryptoJS.enc.Hex.parse(ivKey),key=CryptoJS.enc.Hex.parse(AESKey),bytes=this._descifraAES128(this.scfRequest.encryptedChargeInformation,key,vector);this.paymentData=bytes.toString(CryptoJS.enc.Utf8);this.dispatchEvent(new CustomEvent("decrypt-qr-to-native-event",{detail:[this.paymentData,this.scfRequest.chargeMessageIdentifier]}));this.paymentData={}}else{this.dispatchEvent(new CustomEvent("decrypt-qr-to-native-event",{detail:{}}))}}/**
   * @des Create the Hmac for the Account Validation
   * @param {Object}
   * @event send-hmac-to-native-event
   */},{key:"_createHmacValidateAccount",value:function _createHmacValidateAccount(data){this.keySource=this._XORCipherCustom(data.hmacData.pass,data.hmacData.maKS);var keyHmac=this.keySource.substring(this.googleId64,this.googleId128),hmacData=data.hmacData.alias.toString()+this._addLeftZeros(data.hmacData.dv.toString(),3)+data.hmacData.acc.toString()+data.hmacData.tyc.toString()+this.speiID,hasHex=CryptoJS.enc.Hex.parse(keyHmac),hash=CryptoJS.HmacSHA256(hmacData,hasHex),hashInBase64=CryptoJS.enc.Base64.stringify(hash);this.dispatchEvent(new CustomEvent("send-hmac-to-native-event",{detail:hashInBase64}))}/**
   * @des Create the Hmac for the Query Validation Account
   * @param {Object}
   * @event send-hmac-query-validate-account-event
   */},{key:"_createHmacQueryValidateAccount",value:function _createHmacQueryValidateAccount(data){if(data&&data.hmacData&&data.hmacData.pass){this.keySource=this._XORCipherCustom(data.hmacData.pass,data.hmacData.maKS);var keyHmac=this.keySource.substring(this.googleId64,this.googleId128),dataAccounts=data.hmacData;this.hmacArray=[];for(var indice in dataAccounts.accounts){if(dataAccounts.accounts){var dataAccountsArray=dataAccounts.accounts[indice],hmacData=data.hmacData.alias.toString()+this._addLeftZeros(data.hmacData.dv.toString(),3)+dataAccountsArray.cr.toString(),hasHex=CryptoJS.enc.Hex.parse(keyHmac),hash=CryptoJS.HmacSHA256(hmacData,hasHex),hashInBase64=CryptoJS.enc.Base64.stringify(hash);this.hmacArray.push(hashInBase64)}}this.dispatchEvent(new CustomEvent("send-hmac-query-validate-account-event",{detail:this.hmacArray}))}else{this.dispatchEvent(new CustomEvent("send-hmac-query-validate-account-event",{detail:{}}))}}/**
   * @des Create the Hmac for the Payment History
   * @param {Object}
   * @event send-hmac-history-payment-event
   */},{key:"_createHmacPaymentHistory",value:function _createHmacPaymentHistory(data){if(data&&data.hmacData){var hmacHistory=data.hmacData,indice="";this.hmacArray=[];for(indice in hmacHistory.data){if(hmacHistory.data){var arrayHmacData=hmacHistory.data[indice];this.keySource=this._XORCipherCustom(hmacHistory.pass,hmacHistory.maKS);var keySourceValue=CryptoJS.SHA512(arrayHmacData.id.toString()+this.keySource).toString(CryptoJS.enc.Hex),keyHmac=keySourceValue.substring(this.googleId64,this.googleId128),hmacData=arrayHmacData.alias.toString()+this._addLeftZeros(arrayHmacData.dv.toString(),3)+arrayHmacData.id.toString(),hasHex=CryptoJS.enc.Hex.parse(keyHmac),hash=CryptoJS.HmacSHA256(hmacData,hasHex),hashInBase64=CryptoJS.enc.Base64.stringify(hash);this.hmacArray.push(hashInBase64)}}this.dispatchEvent(new CustomEvent("send-hmac-history-payment-event",{detail:this.hmacArray}))}}/**
   * @des Decrypt Data Payment History
   * @param {Object}
   * @event send-history-payment-event
   */},{key:"_decryptPaymentHistory",value:function _decryptPaymentHistory(infoDatas){var indice="";this.paymentData=[];var decryptPaymentHistory={};decryptPaymentHistory=infoDatas.paymentData.data;for(indice in decryptPaymentHistory){if(decryptPaymentHistory){this.keySource=this._XORCipherCustom(infoDatas.paymentData.pass.toString(),infoDatas.paymentData.maKS.toString());this.infoDataPush=decryptPaymentHistory[indice];var keySourceValue=CryptoJS.SHA512(this.infoDataPush.id.toString()+this.keySource).toString(CryptoJS.enc.Hex),AESKey=keySourceValue.substring(this.googleId0,this.googleId32),ivKey=keySourceValue.substring(this.googleId32,this.googleId64),vector=CryptoJS.enc.Hex.parse(ivKey),key=CryptoJS.enc.Hex.parse(AESKey),bytesHistory="";bytesHistory=this._descifraAES128(this.infoDataPush.listaMC,key,vector);var statusValue=bytesHistory.toString(CryptoJS.enc.Utf8);this.paymentData.push(statusValue)}}this.dispatchEvent(new CustomEvent("send-history-payment-event",{detail:this.paymentData}))}/**
   * @des Encrypt data for QR
   * @param {Object}
   * @event send-encrypted-qr-to-native
   */},{key:"_createQr",value:function _createQr(dataQr){if(dataQr&&dataQr.infoCobro&&dataQr.infoCobro.pass){var now=new Date,encryptQr={};encryptQr=dataQr.infoCobro;encryptQr.DAT=now.getTime();var hexa=this._timestampHex(now);encryptQr.IDC=hexa;this.keySource=this._XORCipherCustom(encryptQr.pass,encryptQr.maKS);var byteArray=CryptoJS.SHA512(encryptQr.IDC+this.keySource+encryptQr.SER.toString()).toString(CryptoJS.enc.Hex),AESKey=byteArray.substring(this.googleId0,this.googleId32),ivKey=byteArray.substring(this.googleId32,this.googleId64),vector=CryptoJS.enc.Hex.parse(ivKey),key=CryptoJS.enc.Hex.parse(AESKey);delete encryptQr.maKS;delete encryptQr.pass;var encryptedPaymentMessage=JSON.stringify(encryptQr),solicitudCobroCif=this._cifraAES128(encryptedPaymentMessage,key,vector),hmacData=encryptQr.v.DEV.split("/")[0]+this._addLeftZeros(encryptQr.v.DEV.split("/")[1].toString(),3)+encryptQr.SER.toString()+encryptedPaymentMessage.toString(),hasHex=CryptoJS.enc.Hex.parse(byteArray.substring(this.googleId64,this.googleId128)),hash=CryptoJS.HmacSHA256(hmacData,hasHex),hashInBase64=CryptoJS.enc.Base64.stringify(hash);this.qrData={};this.qrData={qrValue:{TYP:encryptQr.TYP,v:{DEV:encryptQr.v.DEV},CRY:hashInBase64,ic:{IDC:encryptQr.IDC,SER:encryptQr.SER,ENC:solicitudCobroCif.toString()}}};this.dispatchEvent(new CustomEvent("send-encrypted-qr-to-native",{detail:this.qrData.qrValue}))}else{this.dispatchEvent(new CustomEvent("send-encrypted-qr-to-native",{detail:{}}))}}/**
   * @des Get data encrypted of push notifications
   * @param {Object}
   */},{key:"_getDataPush",value:function _getDataPush(infoDatas){if(infoDatas&&infoDatas.notifData&&infoDatas.notifData.pass){this.infoDataPush={};this.infoDataPush=infoDatas.notifData;var keySourceValue="";this.keySource=this._XORCipherCustom(this.infoDataPush.pass.toString(),this.infoDataPush.maKS.toString());if(this.infoDataPush.mc&&this.infoDataPush.id&&this.infoDataPush.s){keySourceValue=CryptoJS.SHA512(this.infoDataPush.id.toString()+this.keySource+this.infoDataPush.s.toString()).toString(CryptoJS.enc.Hex);this._accountQueryValidationResponse(keySourceValue)}if(this.infoDataPush.infCif&&this.infoDataPush.cr){keySourceValue=CryptoJS.SHA512(this.infoDataPush.cr.toString()+this.keySource).toString(CryptoJS.enc.Hex);this._accountQueryValidationResponse(keySourceValue)}if(this.infoDataPush.id&&this.infoDataPush.mc){keySourceValue=CryptoJS.SHA512(this.infoDataPush.id.toString()+this.keySource).toString(CryptoJS.enc.Hex);this._accountQueryValidationResponse(keySourceValue)}}else{this.dispatchEvent(new CustomEvent("send-decrypted-data-push-event",{detail:{}}))}}/**
   * @des Decrypt Push Payment 20, Account Validation, Payment Status, history Payments
   * @param {Object}
   * @event send-decrypted-data-push-event
   */},{key:"_accountQueryValidationResponse",value:function _accountQueryValidationResponse(keySourceValueSHA512){var keySourceValue=keySourceValueSHA512,bytes="",AESKey=keySourceValue.substring(this.googleId0,this.googleId32),ivKey=keySourceValue.substring(this.googleId32,this.googleId64),vector=CryptoJS.enc.Hex.parse(ivKey),key=CryptoJS.enc.Hex.parse(AESKey),tipoPush="";if(this.infoDataPush.mc&&this.infoDataPush.id){tipoPush=this.infoDataPush.s?"payment20":"statusPayment";bytes=this._descifraAES128(this.infoDataPush.mc,key,vector)}else if(this.infoDataPush.infCif&&this.infoDataPush.cr){tipoPush="accountValidation";bytes=this._descifraAES128(this.infoDataPush.infCif,key,vector)}var statusValue="";statusValue=bytes.toString(CryptoJS.enc.Utf8);this.dispatchEvent(new CustomEvent("account-query-validation-response-loader"));this.dispatchEvent(new CustomEvent("send-decrypted-data-push-event",{detail:{type:tipoPush,pushData:statusValue}}));this.infoDataPush={}}/**
   * @des Decrypt postponed payments.
   * @param {Object}
   * @event send-decrypted-postponed-payment-event
   */},{key:"_postponedPayment",value:function _postponedPayment(dataPayments){if(dataPayments&&dataPayments.infoCif&&dataPayments.infoCif.pass){this.infoDataPayment=dataPayments.infoCif;this.keySource=this._XORCipherCustom(this.infoDataPayment.pass.toString(),this.infoDataPayment.maKS.toString());var paymentsArray=[];for(var data in this.infoDataPayment.encryptData){if(this.infoDataPayment.encryptData){this.paymentData=this.infoDataPayment.encryptData[data];var keySourceValue=CryptoJS.SHA512(this.paymentData.id.toString()+this.keySource+this.paymentData.s.toString()).toString(CryptoJS.enc.Hex),AESKey=keySourceValue.substring(this.googleId0,this.googleId32),ivKey=keySourceValue.substring(this.googleId32,this.googleId64),vector=CryptoJS.enc.Hex.parse(ivKey),key=CryptoJS.enc.Hex.parse(AESKey),dataRefactoring=this.paymentData.mc.replace(/[\\]+/g,""),bytes=this._descifraAES128(dataRefactoring,key,vector),statusValue=bytes.toString(CryptoJS.enc.Utf8);paymentsArray.push(statusValue)}}this.dispatchEvent(new CustomEvent("send-decrypted-postponed-payment-event",{detail:paymentsArray}));this.infoDataPayment={}}else{this.dispatchEvent(new CustomEvent("send-decrypted-postponed-payment-event",{detail:{}}))}}/**
   * @des Methos _cifraAES128 for Encryption AES128 algorithm in CBC mode.
   * @param {Object}
   */},{key:"_cifraAES128",value:function _cifraAES128(mess,key,vector){var encryptionAES128=CryptoJS.AES.encrypt(mess,key,{iv:vector});return encryptionAES128}/**
   * @des Methos _descifraAES128 for Decrypt AES128 algorithm in CBC mode.
   * @param {Object}
   */},{key:"_descifraAES128",value:function _descifraAES128(mess,key,vector){var decodedAES128=CryptoJS.AES.decrypt(mess,key,{iv:vector});return decodedAES128}/**
   * @des Methos _XORCipherCustom for shorten encryption.
   * @param {Object}
   */},{key:"_XORCipherCustom",value:function _XORCipherCustom(keysource,keyDecoded){for(var dataLen=keysource.length,ksArray=[],cdArray=[],hexInt="",hexStr="",_i=0;_i<dataLen;_i+=2){ksArray.push(keysource.substring(_i,_i+2));cdArray.push(keyDecoded.substring(_i,_i+2))}for(var i=0;i<ksArray.length;i++){hexInt=parseInt(ksArray[i],16)^parseInt(cdArray[i],16);hexStr+=this._addLeftZeros(hexInt.toString(16),2)}return hexStr}/**
   * @des Methos _addLeftZeros for place 0 to the left
   * @param {Object}
   */},{key:"_addLeftZeros",value:function _addLeftZeros(value,numberLimit){var limit=numberLimit-value.length;return 0<limit?"0".repeat(limit)+value:value}}],[{key:"is",get:function get(){return"glomo-codi-crypto-dm"}},{key:"properties",get:function get(){return{/**
       * @des Bank identification number provided by Banco de MÃ©xico.
       * @type {String}
       */speiID:{type:String,value:"40012"},/**
       * @des Identifier of the Google project that is required to request the registration of
       * the device in the Google Firebase Notification Service.
       * @type {String}
       */googleId:{type:String,value:""},/**
       * @des Uniquely identifies the app that is installed on the device for each cell number
       * and is assigned by the Bank of Mexico.
       * @type {String}
       */checkDigit:{type:String,value:""},/**
       * @des Number that the user enters when he registers in the application and a sms Banxico is sent to him.
       * @type {String}
       */smsBanxico:{type:String,value:""},/**
       * @des ANDROID_ID followed by a middle script and finally the application identifier (AppID).
       * @des UUID(ios) followed by a middle script and finally the application identifier (AppID).
       * @type {String}
       */hardwareId:{type:String,value:""},/**
       * @des Cell number of the user in which the payment generating app is installed.
       * @type {String}
       */cellPhoneNumber:{type:String,value:""},/**
       * @des Property where the data sent by the initial registration is stored.
       * @type {Object}
       */registerData:{type:Object,value:{}},/**
       * @des Token returned by the Google Firebase service after requesting registration by the application.
       * @type {String}
       */idToken:{type:String,value:""},/**
       * @des Array of bytes for the conformation of symmetric keys.
       * @type {String}
       */keySource:{type:String,value:""},/**
       * @des Byte arrangement for local encryption.
       * @type {String}
       */keySourceLocal:{type:String,value:""},/**
       * @des Masked arrangement of bytes for conformation of symmetric keys that is stored in the local store of the app.
       * @type {String}
       */maskKeySource:{type:String,value:""},/**
       * @des This proporty saves Save a password for the client, which is generated automatically.
       * @type {String}
       */clientPassword:{type:String,value:""},/**
       * @des This property saves an identifier, it is sent by the SrvRegIni in an encrypted way.
       * @type {String}
       */cGoogleId:{type:String,value:""},/**
       * @des Saves decrypted Google Id.
       * @type {String}
       */decryptGoogleId:{type:String,value:""},/**
       * @des Send object data for native.
       * @type {Object}
       */toKeyChain:{type:Object,value:{}},/**
       * @des This property save data QR encrypt
       * @type {Object}
       */qrData:{type:Object,value:{}},/**
       * @des Save data for send to native
       * @type {Object}
       */scfRequest:{type:Object,value:{}},/**
       * @des infoData for save the push encrypted
       * @type {object}
       */infoDataPush:{type:Object,value:{}},/**
       * @des This harcoded data will be used to generate random password
       * @type {Object},
       * @default
       */generatePasswordValues:{type:Object,value:{}},/**
       * @des This property is lenght of googleId with value 0 for generate AESKey
       * @type {Number},
       * @default
       */googleId0:{type:Number,value:0},/**
       * @des This property is lenght of googleId with value 32 for generate AESKey and ivKey
       * @type {Number},
       * @default
       */googleId32:{type:Number,value:32},/**
       * @des This property is lenght of googleId with value 64 for generate ivKey
       * @type {Number},
       * @default
       */googleId64:{type:Number,value:64},/**
       * @des This property is lenght of googleId with value 64 for generate hasHex and keyHmac
       * @type {Number},
       * @default
       */googleId128:{type:Number,value:128},/**
       * @des This property an encrypted key (alias) for each client given by Banxico.
       * @type {String},
       * @default
       */alias:{type:String,value:""},/**
       * @des This property save data for the payment.
       * @type {Object},
       * @default
       */paymentData:{type:Object,value:function value(){return{}}},/**
       * @des This property save the decrypted key (alias).
       * @type {String},
       * @default
       */decryptAlias:{type:String,value:""},/**
       * @des Receive postponed payments data.
       * @type {String},
       * @default
       */infoDataPayment:{type:Object,value:function value(){return{}}}}}}]);return GlomoCodiCryptoDm}(Polymer.mixinBehaviors([CellsBehaviors.i18nBehavior],Polymer.Element));customElements.define(GlomoCodiCryptoDm.is,GlomoCodiCryptoDm);</script><script>;(function(root,factory){if("object"===("undefined"===typeof exports?"undefined":babelHelpers.typeof(exports))){// CommonJS
module.exports=exports=factory()}else if("function"===typeof define&&define.amd){// AMD
define([],factory)}else{// Global (browser)
root.CryptoJS=factory()}})(this,function(){/**
	 * CryptoJS core components.
	 */var CryptoJS=CryptoJS||function(Math,undefined){/*
	     * Local polyfil of Object.create
	     */var create=Object.create||function(){function F(){};return function(obj){var subtype;F.prototype=obj;subtype=new F;F.prototype=null;return subtype}}(),C={},C_lib=C.lib={},Base=C_lib.Base=function(){return{/**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */extend:function extend(overrides){// Spawn
var subtype=create(this);// Augment
if(overrides){subtype.mixIn(overrides)}// Create default initializer
if(!subtype.hasOwnProperty("init")||this.init===subtype.init){subtype.init=function(){subtype.$super.init.apply(this,arguments)}}// Initializer's prototype is the subtype object
subtype.init.prototype=subtype;// Reference supertype
subtype.$super=this;return subtype},/**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */create:function create(){var instance=this.extend();instance.init.apply(instance,arguments);return instance},/**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */init:function init(){},/**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */mixIn:function mixIn(properties){for(var propertyName in properties){if(properties.hasOwnProperty(propertyName)){this[propertyName]=properties[propertyName]}}// IE won't copy toString using the loop above
if(properties.hasOwnProperty("toString")){this.toString=properties.toString}},/**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */clone:function clone(){return this.init.prototype.extend(this)}}}(),WordArray=C_lib.WordArray=Base.extend({/**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */init:function init(words,sigBytes){words=this.words=words||[];if(sigBytes!=void 0){this.sigBytes=sigBytes}else{this.sigBytes=4*words.length}},/**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */toString:function toString(encoder){return(encoder||Hex).stringify(this)},/**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */concat:function concat(wordArray){// Shortcuts
var thisWords=this.words,thatWords=wordArray.words,thisSigBytes=this.sigBytes,thatSigBytes=wordArray.sigBytes;// Clamp excess bits
this.clamp();// Concat
if(thisSigBytes%4){// Copy one byte at a time
for(var i=0,thatByte;i<thatSigBytes;i++){thatByte=255&thatWords[i>>>2]>>>24-8*(i%4);thisWords[thisSigBytes+i>>>2]|=thatByte<<24-8*((thisSigBytes+i)%4)}}else{// Copy one word at a time
for(var i=0;i<thatSigBytes;i+=4){thisWords[thisSigBytes+i>>>2]=thatWords[i>>>2]}}this.sigBytes+=thatSigBytes;// Chainable
return this},/**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */clamp:function clamp(){// Shortcuts
var words=this.words,sigBytes=this.sigBytes;// Clamp
words[sigBytes>>>2]&=4294967295<<32-8*(sigBytes%4);words.length=Math.ceil(sigBytes/4)},/**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */clone:function clone(){var clone=Base.clone.call(this);clone.words=this.words.slice(0);return clone},/**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */random:function random(nBytes){for(var words=[],r=function r(m_w){var m_w=m_w,m_z=987654321,mask=4294967295;return function(){m_z=36969*(65535&m_z)+(m_z>>16)&mask;m_w=18e3*(65535&m_w)+(m_w>>16)&mask;var result=(m_z<<16)+m_w&mask;result/=4294967296;result+=.5;return result*(.5<Math.random()?1:-1)}},i=0,rcache,_r;i<nBytes;i+=4){_r=r(4294967296*(rcache||Math.random()));rcache=987654071*_r();words.push(0|4294967296*_r())}return new WordArray.init(words,nBytes)}}),C_enc=C.enc={},Hex=C_enc.Hex={/**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */stringify:function stringify(wordArray){// Shortcuts
for(var words=wordArray.words,sigBytes=wordArray.sigBytes,hexChars=[],i=0,bite;i<sigBytes;i++){bite=255&words[i>>>2]>>>24-8*(i%4);hexChars.push((bite>>>4).toString(16));hexChars.push((15&bite).toString(16))}return hexChars.join("")},/**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */parse:function parse(hexStr){// Shortcut
for(var hexStrLength=hexStr.length,words=[],i=0;i<hexStrLength;i+=2){words[i>>>3]|=parseInt(hexStr.substr(i,2),16)<<24-4*(i%8)}return new WordArray.init(words,hexStrLength/2)}},Latin1=C_enc.Latin1={/**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */stringify:function stringify(wordArray){// Shortcuts
for(var words=wordArray.words,sigBytes=wordArray.sigBytes,latin1Chars=[],i=0,bite;i<sigBytes;i++){bite=255&words[i>>>2]>>>24-8*(i%4);latin1Chars.push(String.fromCharCode(bite))}return latin1Chars.join("")},/**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */parse:function parse(latin1Str){// Shortcut
for(var latin1StrLength=latin1Str.length,words=[],i=0;i<latin1StrLength;i++){words[i>>>2]|=(255&latin1Str.charCodeAt(i))<<24-8*(i%4)}return new WordArray.init(words,latin1StrLength)}},Utf8=C_enc.Utf8={/**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */stringify:function stringify(wordArray){try{return decodeURIComponent(escape(Latin1.stringify(wordArray)))}catch(e){throw new Error("Malformed UTF-8 data")}},/**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */parse:function parse(utf8Str){return Latin1.parse(unescape(encodeURIComponent(utf8Str)))}},BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm=Base.extend({/**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */reset:function reset(){// Initial values
this._data=new WordArray.init;this._nDataBytes=0},/**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */_append:function _append(data){// Convert string to WordArray, else assume WordArray already
if("string"==typeof data){data=Utf8.parse(data)}// Append
this._data.concat(data);this._nDataBytes+=data.sigBytes},/**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */_process:function _process(doFlush){// Shortcuts
var data=this._data,dataWords=data.words,dataSigBytes=data.sigBytes,blockSize=this.blockSize,blockSizeBytes=4*blockSize,nBlocksReady=dataSigBytes/blockSizeBytes;if(doFlush){// Round up to include partial blocks
nBlocksReady=Math.ceil(nBlocksReady)}else{// Round down to include only full blocks,
// less the number of blocks that must remain in the buffer
nBlocksReady=Math.max((0|nBlocksReady)-this._minBufferSize,0)}// Count words ready
var nWordsReady=nBlocksReady*blockSize,nBytesReady=Math.min(4*nWordsReady,dataSigBytes);// Count bytes ready
// Process blocks
if(nWordsReady){for(var offset=0;offset<nWordsReady;offset+=blockSize){// Perform concrete-algorithm logic
this._doProcessBlock(dataWords,offset)}// Remove processed words
var processedWords=dataWords.splice(0,nWordsReady);data.sigBytes-=nBytesReady}// Return processed words
return new WordArray.init(processedWords,nBytesReady)},/**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */clone:function clone(){var clone=Base.clone.call(this);clone._data=this._data.clone();return clone},_minBufferSize:0}),Hasher=C_lib.Hasher=BufferedBlockAlgorithm.extend({/**
	         * Configuration options.
	         */cfg:Base.extend(),/**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */init:function init(cfg){// Apply config defaults
this.cfg=this.cfg.extend(cfg);// Set initial values
this.reset()},/**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */reset:function reset(){// Reset data buffer
BufferedBlockAlgorithm.reset.call(this);// Perform concrete-hasher logic
this._doReset()},/**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */update:function update(messageUpdate){// Append
this._append(messageUpdate);// Update the hash
this._process();// Chainable
return this},/**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */finalize:function finalize(messageUpdate){// Final message update
if(messageUpdate){this._append(messageUpdate)}// Perform concrete-hasher logic
var hash=this._doFinalize();return hash},blockSize:512/32,/**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */_createHelper:function _createHelper(hasher){return function(message,cfg){return new hasher.init(cfg).finalize(message)}},/**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */_createHmacHelper:function _createHmacHelper(hasher){return function(message,key){return new C_algo.HMAC.init(hasher,key).finalize(message)}}}),C_algo=C.algo={};/**
	     * CryptoJS namespace.
	     */return C}(Math);(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,C_enc=C.enc,Base64=C_enc.Base64={/**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */stringify:function stringify(wordArray){// Shortcuts
var words=wordArray.words,sigBytes=wordArray.sigBytes,map=this._map;// Clamp excess bits
wordArray.clamp();// Convert
for(var base64Chars=[],i=0;i<sigBytes;i+=3){for(var byte1=255&words[i>>>2]>>>24-8*(i%4),byte2=255&words[i+1>>>2]>>>24-8*((i+1)%4),byte3=255&words[i+2>>>2]>>>24-8*((i+2)%4),triplet=byte1<<16|byte2<<8|byte3,j=0;4>j&&i+.75*j<sigBytes;j++){base64Chars.push(map.charAt(63&triplet>>>6*(3-j)))}}// Add padding
var paddingChar=map.charAt(64);if(paddingChar){while(base64Chars.length%4){base64Chars.push(paddingChar)}}return base64Chars.join("")},/**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */parse:function parse(base64Str){// Shortcuts
var base64StrLength=base64Str.length,map=this._map,reverseMap=this._reverseMap;if(!reverseMap){reverseMap=this._reverseMap=[];for(var j=0;j<map.length;j++){reverseMap[map.charCodeAt(j)]=j}}// Ignore padding
var paddingChar=map.charAt(64);if(paddingChar){var paddingIndex=base64Str.indexOf(paddingChar);if(-1!==paddingIndex){base64StrLength=paddingIndex}}// Convert
return parseLoop(base64Str,base64StrLength,reverseMap)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="};function parseLoop(base64Str,base64StrLength,reverseMap){for(var words=[],nBytes=0,i=0;i<base64StrLength;i++){if(i%4){var bits1=reverseMap[base64Str.charCodeAt(i-1)]<<2*(i%4),bits2=reverseMap[base64Str.charCodeAt(i)]>>>6-2*(i%4);words[nBytes>>>2]|=(bits1|bits2)<<24-8*(nBytes%4);nBytes++}}return WordArray.create(words,nBytes)}})();(function(Math){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,Hasher=C_lib.Hasher,C_algo=C.algo,T=[];// Compute constants
(function(){for(var i=0;64>i;i++){T[i]=0|4294967296*Math.abs(Math.sin(i+1))}})();/**
	     * MD5 hash algorithm.
	     */var MD5=C_algo.MD5=Hasher.extend({_doReset:function _doReset(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function _doProcessBlock(M,offset){// Swap endian
for(var i=0;16>i;i++){// Shortcuts
var offset_i=offset+i,M_offset_i=M[offset_i];M[offset_i]=16711935&(M_offset_i<<8|M_offset_i>>>24)|4278255360&(M_offset_i<<24|M_offset_i>>>8)}// Shortcuts
var H=this._hash.words,M_offset_0=M[offset+0],M_offset_1=M[offset+1],M_offset_2=M[offset+2],M_offset_3=M[offset+3],M_offset_4=M[offset+4],M_offset_5=M[offset+5],M_offset_6=M[offset+6],M_offset_7=M[offset+7],M_offset_8=M[offset+8],M_offset_9=M[offset+9],M_offset_10=M[offset+10],M_offset_11=M[offset+11],M_offset_12=M[offset+12],M_offset_13=M[offset+13],M_offset_14=M[offset+14],M_offset_15=M[offset+15],a=H[0],b=H[1],c=H[2],d=H[3];// Computation
a=FF(a,b,c,d,M_offset_0,7,T[0]);d=FF(d,a,b,c,M_offset_1,12,T[1]);c=FF(c,d,a,b,M_offset_2,17,T[2]);b=FF(b,c,d,a,M_offset_3,22,T[3]);a=FF(a,b,c,d,M_offset_4,7,T[4]);d=FF(d,a,b,c,M_offset_5,12,T[5]);c=FF(c,d,a,b,M_offset_6,17,T[6]);b=FF(b,c,d,a,M_offset_7,22,T[7]);a=FF(a,b,c,d,M_offset_8,7,T[8]);d=FF(d,a,b,c,M_offset_9,12,T[9]);c=FF(c,d,a,b,M_offset_10,17,T[10]);b=FF(b,c,d,a,M_offset_11,22,T[11]);a=FF(a,b,c,d,M_offset_12,7,T[12]);d=FF(d,a,b,c,M_offset_13,12,T[13]);c=FF(c,d,a,b,M_offset_14,17,T[14]);b=FF(b,c,d,a,M_offset_15,22,T[15]);a=GG(a,b,c,d,M_offset_1,5,T[16]);d=GG(d,a,b,c,M_offset_6,9,T[17]);c=GG(c,d,a,b,M_offset_11,14,T[18]);b=GG(b,c,d,a,M_offset_0,20,T[19]);a=GG(a,b,c,d,M_offset_5,5,T[20]);d=GG(d,a,b,c,M_offset_10,9,T[21]);c=GG(c,d,a,b,M_offset_15,14,T[22]);b=GG(b,c,d,a,M_offset_4,20,T[23]);a=GG(a,b,c,d,M_offset_9,5,T[24]);d=GG(d,a,b,c,M_offset_14,9,T[25]);c=GG(c,d,a,b,M_offset_3,14,T[26]);b=GG(b,c,d,a,M_offset_8,20,T[27]);a=GG(a,b,c,d,M_offset_13,5,T[28]);d=GG(d,a,b,c,M_offset_2,9,T[29]);c=GG(c,d,a,b,M_offset_7,14,T[30]);b=GG(b,c,d,a,M_offset_12,20,T[31]);a=HH(a,b,c,d,M_offset_5,4,T[32]);d=HH(d,a,b,c,M_offset_8,11,T[33]);c=HH(c,d,a,b,M_offset_11,16,T[34]);b=HH(b,c,d,a,M_offset_14,23,T[35]);a=HH(a,b,c,d,M_offset_1,4,T[36]);d=HH(d,a,b,c,M_offset_4,11,T[37]);c=HH(c,d,a,b,M_offset_7,16,T[38]);b=HH(b,c,d,a,M_offset_10,23,T[39]);a=HH(a,b,c,d,M_offset_13,4,T[40]);d=HH(d,a,b,c,M_offset_0,11,T[41]);c=HH(c,d,a,b,M_offset_3,16,T[42]);b=HH(b,c,d,a,M_offset_6,23,T[43]);a=HH(a,b,c,d,M_offset_9,4,T[44]);d=HH(d,a,b,c,M_offset_12,11,T[45]);c=HH(c,d,a,b,M_offset_15,16,T[46]);b=HH(b,c,d,a,M_offset_2,23,T[47]);a=II(a,b,c,d,M_offset_0,6,T[48]);d=II(d,a,b,c,M_offset_7,10,T[49]);c=II(c,d,a,b,M_offset_14,15,T[50]);b=II(b,c,d,a,M_offset_5,21,T[51]);a=II(a,b,c,d,M_offset_12,6,T[52]);d=II(d,a,b,c,M_offset_3,10,T[53]);c=II(c,d,a,b,M_offset_10,15,T[54]);b=II(b,c,d,a,M_offset_1,21,T[55]);a=II(a,b,c,d,M_offset_8,6,T[56]);d=II(d,a,b,c,M_offset_15,10,T[57]);c=II(c,d,a,b,M_offset_6,15,T[58]);b=II(b,c,d,a,M_offset_13,21,T[59]);a=II(a,b,c,d,M_offset_4,6,T[60]);d=II(d,a,b,c,M_offset_11,10,T[61]);c=II(c,d,a,b,M_offset_2,15,T[62]);b=II(b,c,d,a,M_offset_9,21,T[63]);// Intermediate hash value
H[0]=0|H[0]+a;H[1]=0|H[1]+b;H[2]=0|H[2]+c;H[3]=0|H[3]+d},_doFinalize:function _doFinalize(){// Shortcuts
var data=this._data,dataWords=data.words,nBitsTotal=8*this._nDataBytes,nBitsLeft=8*data.sigBytes;// Add padding
dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;var nBitsTotalH=Math.floor(nBitsTotal/4294967296),nBitsTotalL=nBitsTotal;dataWords[(nBitsLeft+64>>>9<<4)+15]=16711935&(nBitsTotalH<<8|nBitsTotalH>>>24)|4278255360&(nBitsTotalH<<24|nBitsTotalH>>>8);dataWords[(nBitsLeft+64>>>9<<4)+14]=16711935&(nBitsTotalL<<8|nBitsTotalL>>>24)|4278255360&(nBitsTotalL<<24|nBitsTotalL>>>8);data.sigBytes=4*(dataWords.length+1);// Hash final blocks
this._process();// Shortcuts
// Swap endian
for(var hash=this._hash,H=hash.words,i=0,H_i;4>i;i++){// Shortcut
H_i=H[i];H[i]=16711935&(H_i<<8|H_i>>>24)|4278255360&(H_i<<24|H_i>>>8)}// Return final computed hash
return hash},clone:function clone(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function FF(a,b,c,d,x,s,t){var n=a+(b&c|~b&d)+x+t;return(n<<s|n>>>32-s)+b}function GG(a,b,c,d,x,s,t){var n=a+(b&d|c&~d)+x+t;return(n<<s|n>>>32-s)+b}function HH(a,b,c,d,x,s,t){var n=a+(b^c^d)+x+t;return(n<<s|n>>>32-s)+b}function II(a,b,c,d,x,s,t){var n=a+(c^(b|~d))+x+t;return(n<<s|n>>>32-s)+b}/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */C.MD5=Hasher._createHelper(MD5);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */C.HmacMD5=Hasher._createHmacHelper(MD5)})(Math);(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,Hasher=C_lib.Hasher,C_algo=C.algo,W=[],SHA1=C_algo.SHA1=Hasher.extend({_doReset:function _doReset(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function _doProcessBlock(M,offset){// Shortcut
// Computation
for(var H=this._hash.words,a=H[0],b=H[1],c=H[2],d=H[3],e=H[4],i=0;80>i;i++){if(16>i){W[i]=0|M[offset+i]}else{var n=W[i-3]^W[i-8]^W[i-14]^W[i-16];W[i]=n<<1|n>>>31}var t=(a<<5|a>>>27)+e+W[i];if(20>i){t+=(b&c|~b&d)+1518500249}else if(40>i){t+=(b^c^d)+1859775393}else if(60>i){t+=(b&c|b&d|c&d)-1894007588}else/* if (i < 80) */{t+=(b^c^d)-899497514}e=d;d=c;c=b<<30|b>>>2;b=a;a=t}// Intermediate hash value
H[0]=0|H[0]+a;H[1]=0|H[1]+b;H[2]=0|H[2]+c;H[3]=0|H[3]+d;H[4]=0|H[4]+e},_doFinalize:function _doFinalize(){// Shortcuts
var data=this._data,dataWords=data.words,nBitsTotal=8*this._nDataBytes,nBitsLeft=8*data.sigBytes;// Add padding
dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=4*dataWords.length;// Hash final blocks
this._process();// Return final computed hash
return this._hash},clone:function clone(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */C.SHA1=Hasher._createHelper(SHA1);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */C.HmacSHA1=Hasher._createHmacHelper(SHA1)})();(function(Math){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,Hasher=C_lib.Hasher,C_algo=C.algo,H=[],K=[];// Compute constants
(function(){function isPrime(n){for(var sqrtN=Math.sqrt(n),factor=2;factor<=sqrtN;factor++){if(!(n%factor)){return!1}}return!0}function getFractionalBits(n){return 0|4294967296*(n-(0|n))}var n=2,nPrime=0;while(64>nPrime){if(isPrime(n)){if(8>nPrime){H[nPrime]=getFractionalBits(Math.pow(n,1/2))}K[nPrime]=getFractionalBits(Math.pow(n,1/3));nPrime++}n++}})();// Reusable object
var W=[],SHA256=C_algo.SHA256=Hasher.extend({_doReset:function _doReset(){this._hash=new WordArray.init(H.slice(0))},_doProcessBlock:function _doProcessBlock(M,offset){// Shortcut
// Computation
for(var H=this._hash.words,a=H[0],b=H[1],c=H[2],d=H[3],e=H[4],f=H[5],g=H[6],h=H[7],i=0;64>i;i++){if(16>i){W[i]=0|M[offset+i]}else{var gamma0x=W[i-15],gamma0=(gamma0x<<25|gamma0x>>>7)^(gamma0x<<14|gamma0x>>>18)^gamma0x>>>3,gamma1x=W[i-2],gamma1=(gamma1x<<15|gamma1x>>>17)^(gamma1x<<13|gamma1x>>>19)^gamma1x>>>10;W[i]=gamma0+W[i-7]+gamma1+W[i-16]}var ch=e&f^~e&g,maj=a&b^a&c^b&c,sigma0=(a<<30|a>>>2)^(a<<19|a>>>13)^(a<<10|a>>>22),sigma1=(e<<26|e>>>6)^(e<<21|e>>>11)^(e<<7|e>>>25),t1=h+sigma1+ch+K[i]+W[i],t2=sigma0+maj;h=g;g=f;f=e;e=0|d+t1;d=c;c=b;b=a;a=0|t1+t2}// Intermediate hash value
H[0]=0|H[0]+a;H[1]=0|H[1]+b;H[2]=0|H[2]+c;H[3]=0|H[3]+d;H[4]=0|H[4]+e;H[5]=0|H[5]+f;H[6]=0|H[6]+g;H[7]=0|H[7]+h},_doFinalize:function _doFinalize(){// Shortcuts
var data=this._data,dataWords=data.words,nBitsTotal=8*this._nDataBytes,nBitsLeft=8*data.sigBytes;// Add padding
dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=4*dataWords.length;// Hash final blocks
this._process();// Return final computed hash
return this._hash},clone:function clone(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});/**
	     * SHA-256 hash algorithm.
	     */ /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */C.SHA256=Hasher._createHelper(SHA256);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */C.HmacSHA256=Hasher._createHmacHelper(SHA256)})(Math);(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,C_enc=C.enc,Utf16BE=C_enc.Utf16=C_enc.Utf16BE={/**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */stringify:function stringify(wordArray){// Shortcuts
for(var words=wordArray.words,sigBytes=wordArray.sigBytes,utf16Chars=[],i=0,codePoint;i<sigBytes;i+=2){codePoint=65535&words[i>>>2]>>>16-8*(i%4);utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},/**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */parse:function parse(utf16Str){// Shortcut
for(var utf16StrLength=utf16Str.length,words=[],i=0;i<utf16StrLength;i++){words[i>>>1]|=utf16Str.charCodeAt(i)<<16-16*(i%2)}return WordArray.create(words,2*utf16StrLength)}};/**
	     * UTF-16 LE encoding strategy.
	     */C_enc.Utf16LE={/**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */stringify:function stringify(wordArray){// Shortcuts
for(var words=wordArray.words,sigBytes=wordArray.sigBytes,utf16Chars=[],i=0,codePoint;i<sigBytes;i+=2){codePoint=swapEndian(65535&words[i>>>2]>>>16-8*(i%4));utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},/**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */parse:function parse(utf16Str){// Shortcut
for(var utf16StrLength=utf16Str.length,words=[],i=0;i<utf16StrLength;i++){words[i>>>1]|=swapEndian(utf16Str.charCodeAt(i)<<16-16*(i%2))}return WordArray.create(words,2*utf16StrLength)}};function swapEndian(word){return 4278255360&word<<8|16711935&word>>>8}})();(function(){// Check if typed arrays are supported
if("function"!=typeof ArrayBuffer){return}// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,superInit=WordArray.init,subInit=WordArray.init=function(typedArray){// Convert buffers to uint8
if(babelHelpers.instanceof(typedArray,ArrayBuffer)){typedArray=new Uint8Array(typedArray)}// Convert other array views to uint8
if(babelHelpers.instanceof(typedArray,Int8Array)||"undefined"!==typeof Uint8ClampedArray&&babelHelpers.instanceof(typedArray,Uint8ClampedArray)||babelHelpers.instanceof(typedArray,Int16Array)||babelHelpers.instanceof(typedArray,Uint16Array)||babelHelpers.instanceof(typedArray,Int32Array)||babelHelpers.instanceof(typedArray,Uint32Array)||babelHelpers.instanceof(typedArray,Float32Array)||babelHelpers.instanceof(typedArray,Float64Array)){typedArray=new Uint8Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength)}// Handle Uint8Array
if(babelHelpers.instanceof(typedArray,Uint8Array)){// Shortcut
for(var typedArrayByteLength=typedArray.byteLength,words=[],i=0;i<typedArrayByteLength;i++){words[i>>>2]|=typedArray[i]<<24-8*(i%4)}// Initialize this word array
superInit.call(this,words,typedArrayByteLength)}else{// Else call normal init
superInit.apply(this,arguments)}};subInit.prototype=WordArray})();/** @preserve
	(c) 2012 by CÃ©dric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/(function(Math){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,Hasher=C_lib.Hasher,C_algo=C.algo,_zl=WordArray.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),_zr=WordArray.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),_sl=WordArray.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),_sr=WordArray.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),_hl=WordArray.create([0,1518500249,1859775393,2400959708,2840853838]),_hr=WordArray.create([1352829926,1548603684,1836072691,2053994217,0]),RIPEMD160=C_algo.RIPEMD160=Hasher.extend({_doReset:function _doReset(){this._hash=WordArray.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function _doProcessBlock(M,offset){// Swap endian
for(var i=0;16>i;i++){// Shortcuts
var offset_i=offset+i,M_offset_i=M[offset_i];// Swap
M[offset_i]=16711935&(M_offset_i<<8|M_offset_i>>>24)|4278255360&(M_offset_i<<24|M_offset_i>>>8)}// Shortcut
var H=this._hash.words,hl=_hl.words,hr=_hr.words,zl=_zl.words,zr=_zr.words,sl=_sl.words,sr=_sr.words,al,bl,cl,dl,el,ar,br,cr,dr,er;ar=al=H[0];br=bl=H[1];cr=cl=H[2];dr=dl=H[3];er=el=H[4];// Computation
for(var t,i=0;80>i;i+=1){t=0|al+M[offset+zl[i]];if(16>i){t+=f1(bl,cl,dl)+hl[0]}else if(32>i){t+=f2(bl,cl,dl)+hl[1]}else if(48>i){t+=f3(bl,cl,dl)+hl[2]}else if(64>i){t+=f4(bl,cl,dl)+hl[3]}else{// if (i<80) {
t+=f5(bl,cl,dl)+hl[4]}t=0|t;t=rotl(t,sl[i]);t=0|t+el;al=el;el=dl;dl=rotl(cl,10);cl=bl;bl=t;t=0|ar+M[offset+zr[i]];if(16>i){t+=f5(br,cr,dr)+hr[0]}else if(32>i){t+=f4(br,cr,dr)+hr[1]}else if(48>i){t+=f3(br,cr,dr)+hr[2]}else if(64>i){t+=f2(br,cr,dr)+hr[3]}else{// if (i<80) {
t+=f1(br,cr,dr)+hr[4]}t=0|t;t=rotl(t,sr[i]);t=0|t+er;ar=er;er=dr;dr=rotl(cr,10);cr=br;br=t}// Intermediate hash value
t=0|H[1]+cl+dr;H[1]=0|H[2]+dl+er;H[2]=0|H[3]+el+ar;H[3]=0|H[4]+al+br;H[4]=0|H[0]+bl+cr;H[0]=t},_doFinalize:function _doFinalize(){// Shortcuts
var data=this._data,dataWords=data.words,nBitsTotal=8*this._nDataBytes,nBitsLeft=8*data.sigBytes;// Add padding
dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=16711935&(nBitsTotal<<8|nBitsTotal>>>24)|4278255360&(nBitsTotal<<24|nBitsTotal>>>8);data.sigBytes=4*(dataWords.length+1);// Hash final blocks
this._process();// Shortcuts
// Swap endian
for(var hash=this._hash,H=hash.words,i=0,H_i;5>i;i++){// Shortcut
H_i=H[i];// Swap
H[i]=16711935&(H_i<<8|H_i>>>24)|4278255360&(H_i<<24|H_i>>>8)}// Return final computed hash
return hash},clone:function clone(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function f1(x,y,z){return x^y^z}function f2(x,y,z){return x&y|~x&z}function f3(x,y,z){return(x|~y)^z}function f4(x,y,z){return x&z|y&~z}function f5(x,y,z){return x^(y|~z)}function rotl(x,n){return x<<n|x>>>32-n}/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */C.RIPEMD160=Hasher._createHelper(RIPEMD160);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */C.HmacRIPEMD160=Hasher._createHmacHelper(RIPEMD160)})(Math);(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,Base=C_lib.Base,C_enc=C.enc,Utf8=C_enc.Utf8,C_algo=C.algo,HMAC=C_algo.HMAC=Base.extend({/**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */init:function init(hasher,key){// Init hasher
hasher=this._hasher=new hasher.init;// Convert string to WordArray, else assume WordArray already
if("string"==typeof key){key=Utf8.parse(key)}// Shortcuts
var hasherBlockSize=hasher.blockSize,hasherBlockSizeBytes=4*hasherBlockSize;// Allow arbitrary length keys
if(key.sigBytes>hasherBlockSizeBytes){key=hasher.finalize(key)}// Clamp excess bits
key.clamp();// Clone key for inner and outer pads
// XOR keys with pad constants
for(var oKey=this._oKey=key.clone(),iKey=this._iKey=key.clone(),oKeyWords=oKey.words,iKeyWords=iKey.words,i=0;i<hasherBlockSize;i++){oKeyWords[i]^=1549556828;iKeyWords[i]^=909522486}oKey.sigBytes=iKey.sigBytes=hasherBlockSizeBytes;// Set initial values
this.reset()},/**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */reset:function reset(){// Shortcut
var hasher=this._hasher;// Reset
hasher.reset();hasher.update(this._iKey)},/**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */update:function update(messageUpdate){this._hasher.update(messageUpdate);// Chainable
return this},/**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */finalize:function finalize(messageUpdate){// Shortcut
var hasher=this._hasher,innerHash=hasher.finalize(messageUpdate);// Compute HMAC
hasher.reset();var hmac=hasher.finalize(this._oKey.clone().concat(innerHash));return hmac}})})();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,Base=C_lib.Base,WordArray=C_lib.WordArray,C_algo=C.algo,SHA1=C_algo.SHA1,HMAC=C_algo.HMAC,PBKDF2=C_algo.PBKDF2=Base.extend({/**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */cfg:Base.extend({keySize:128/32,hasher:SHA1,iterations:1}),/**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */init:function init(cfg){this.cfg=this.cfg.extend(cfg)},/**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */compute:function compute(password,salt){// Shortcut
var cfg=this.cfg,hmac=HMAC.create(cfg.hasher,password),derivedKey=WordArray.create(),blockIndex=WordArray.create([1]),derivedKeyWords=derivedKey.words,blockIndexWords=blockIndex.words,keySize=cfg.keySize,iterations=cfg.iterations;// Init HMAC
// Generate key
while(derivedKeyWords.length<keySize){var block=hmac.update(salt).finalize(blockIndex);hmac.reset();// Shortcuts
for(var blockWords=block.words,blockWordsLength=blockWords.length,intermediate=block,i=1;i<iterations;i++){intermediate=hmac.finalize(intermediate);hmac.reset();// Shortcut
// XOR intermediate with block
for(var intermediateWords=intermediate.words,j=0;j<blockWordsLength;j++){blockWords[j]^=intermediateWords[j]}}derivedKey.concat(block);blockIndexWords[0]++}derivedKey.sigBytes=4*keySize;return derivedKey}});/**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */C.PBKDF2=function(password,salt,cfg){return PBKDF2.create(cfg).compute(password,salt)}})();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,Base=C_lib.Base,WordArray=C_lib.WordArray,C_algo=C.algo,MD5=C_algo.MD5,EvpKDF=C_algo.EvpKDF=Base.extend({/**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */cfg:Base.extend({keySize:128/32,hasher:MD5,iterations:1}),/**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */init:function init(cfg){this.cfg=this.cfg.extend(cfg)},/**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */compute:function compute(password,salt){// Shortcut
var cfg=this.cfg,hasher=cfg.hasher.create(),derivedKey=WordArray.create(),derivedKeyWords=derivedKey.words,keySize=cfg.keySize,iterations=cfg.iterations;// Init hasher
// Generate key
while(derivedKeyWords.length<keySize){if(block){hasher.update(block)}var block=hasher.update(password).finalize(salt);hasher.reset();// Iterations
for(var i=1;i<iterations;i++){block=hasher.finalize(block);hasher.reset()}derivedKey.concat(block)}derivedKey.sigBytes=4*keySize;return derivedKey}});/**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */C.EvpKDF=function(password,salt,cfg){return EvpKDF.create(cfg).compute(password,salt)}})();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,C_algo=C.algo,SHA256=C_algo.SHA256,SHA224=C_algo.SHA224=SHA256.extend({_doReset:function _doReset(){this._hash=new WordArray.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function _doFinalize(){var hash=SHA256._doFinalize.call(this);hash.sigBytes-=4;return hash}});/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */C.SHA224=SHA256._createHelper(SHA224);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */C.HmacSHA224=SHA256._createHmacHelper(SHA224)})();(function(undefined){// Shortcuts
var C=CryptoJS,C_lib=C.lib,Base=C_lib.Base,X32WordArray=C_lib.WordArray,C_x64=C.x64={},X64Word=C_x64.Word=Base.extend({/**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */init:function init(high,low){this.high=high;this.low=low}/**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */ // not: function () {
// var high = ~this.high;
// var low = ~this.low;
// return X64Word.create(high, low);
// },
/**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */ // and: function (word) {
// var high = this.high & word.high;
// var low = this.low & word.low;
// return X64Word.create(high, low);
// },
/**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */ // or: function (word) {
// var high = this.high | word.high;
// var low = this.low | word.low;
// return X64Word.create(high, low);
// },
/**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */ // xor: function (word) {
// var high = this.high ^ word.high;
// var low = this.low ^ word.low;
// return X64Word.create(high, low);
// },
/**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */ // shiftL: function (n) {
// if (n < 32) {
// var high = (this.high << n) | (this.low >>> (32 - n));
// var low = this.low << n;
// } else {
// var high = this.low << (n - 32);
// var low = 0;
// }
// return X64Word.create(high, low);
// },
/**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */ // shiftR: function (n) {
// if (n < 32) {
// var low = (this.low >>> n) | (this.high << (32 - n));
// var high = this.high >>> n;
// } else {
// var low = this.high >>> (n - 32);
// var high = 0;
// }
// return X64Word.create(high, low);
// },
/**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */ // rotL: function (n) {
// return this.shiftL(n).or(this.shiftR(64 - n));
// },
/**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */ // rotR: function (n) {
// return this.shiftR(n).or(this.shiftL(64 - n));
// },
/**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */ // add: function (word) {
// var low = (this.low + word.low) | 0;
// var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
// var high = (this.high + word.high + carry) | 0;
// return X64Word.create(high, low);
// }
}),X64WordArray=C_x64.WordArray=Base.extend({/**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */init:function init(words,sigBytes){words=this.words=words||[];if(sigBytes!=void 0){this.sigBytes=sigBytes}else{this.sigBytes=8*words.length}},/**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */toX32:function toX32(){// Shortcuts
for(var x64Words=this.words,x64WordsLength=x64Words.length,x32Words=[],i=0,x64Word;i<x64WordsLength;i++){x64Word=x64Words[i];x32Words.push(x64Word.high);x32Words.push(x64Word.low)}return X32WordArray.create(x32Words,this.sigBytes)},/**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */clone:function clone(){for(var clone=Base.clone.call(this),words=clone.words=this.words.slice(0),wordsLength=words.length,i=0;i<wordsLength;i++){words[i]=words[i].clone()}return clone}})})();(function(Math){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,Hasher=C_lib.Hasher,C_x64=C.x64,X64Word=C_x64.Word,C_algo=C.algo,RHO_OFFSETS=[],PI_INDEXES=[],ROUND_CONSTANTS=[];// Compute Constants
(function(){// Compute rho offset constants
for(var x=1,y=0,t=0;24>t;t++){RHO_OFFSETS[x+5*y]=(t+1)*(t+2)/2%64;var newX=y%5,newY=(2*x+3*y)%5;x=newX;y=newY}// Compute pi index constants
for(var x=0;5>x;x++){for(var y=0;5>y;y++){PI_INDEXES[x+5*y]=y+5*((2*x+3*y)%5)}}// Compute round constants
for(var LFSR=1,i=0;24>i;i++){for(var roundConstantMsw=0,roundConstantLsw=0,j=0;7>j;j++){if(1&LFSR){var bitPosition=(1<<j)-1;if(32>bitPosition){roundConstantLsw^=1<<bitPosition}else/* if (bitPosition >= 32) */{roundConstantMsw^=1<<bitPosition-32}}// Compute next LFSR
if(128&LFSR){// Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
LFSR=113^LFSR<<1}else{LFSR<<=1}}ROUND_CONSTANTS[i]=X64Word.create(roundConstantMsw,roundConstantLsw)}})();// Reusable objects for temporary values
var T=[];(function(){for(var i=0;25>i;i++){T[i]=X64Word.create()}})();/**
	     * SHA-3 hash algorithm.
	     */var SHA3=C_algo.SHA3=Hasher.extend({/**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */cfg:Hasher.cfg.extend({outputLength:512}),_doReset:function _doReset(){for(var state=this._state=[],i=0;25>i;i++){state[i]=new X64Word.init}this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function _doProcessBlock(M,offset){// Shortcuts
// Absorb
for(var state=this._state,nBlockSizeLanes=this.blockSize/2,i=0;i<nBlockSizeLanes;i++){// Shortcuts
var M2i=M[offset+2*i],M2i1=M[offset+2*i+1];// Swap endian
M2i=16711935&(M2i<<8|M2i>>>24)|4278255360&(M2i<<24|M2i>>>8);M2i1=16711935&(M2i1<<8|M2i1>>>24)|4278255360&(M2i1<<24|M2i1>>>8);// Absorb message into state
var lane=state[i];lane.high^=M2i1;lane.low^=M2i}// Rounds
for(var round=0;24>round;round++){// Theta
for(var x=0;5>x;x++){// Mix column lanes
for(var tMsw=0,tLsw=0,y=0,lane;5>y;y++){lane=state[x+5*y];tMsw^=lane.high;tLsw^=lane.low}// Temporary values
var Tx=T[x];Tx.high=tMsw;Tx.low=tLsw}for(var x=0;5>x;x++){// Shortcuts
for(var Tx4=T[(x+4)%5],Tx1=T[(x+1)%5],Tx1Msw=Tx1.high,Tx1Lsw=Tx1.low,tMsw=Tx4.high^(Tx1Msw<<1|Tx1Lsw>>>31),tLsw=Tx4.low^(Tx1Lsw<<1|Tx1Msw>>>31),y=0,lane;5>y;y++){lane=state[x+5*y];lane.high^=tMsw;lane.low^=tLsw}}// Rho Pi
for(var laneIndex=1;25>laneIndex;laneIndex++){// Shortcuts
var lane=state[laneIndex],laneMsw=lane.high,laneLsw=lane.low,rhoOffset=RHO_OFFSETS[laneIndex];// Rotate lanes
if(32>rhoOffset){var tMsw=laneMsw<<rhoOffset|laneLsw>>>32-rhoOffset,tLsw=laneLsw<<rhoOffset|laneMsw>>>32-rhoOffset}else/* if (rhoOffset >= 32) */{var tMsw=laneLsw<<rhoOffset-32|laneMsw>>>64-rhoOffset,tLsw=laneMsw<<rhoOffset-32|laneLsw>>>64-rhoOffset}// Transpose lanes
var TPiLane=T[PI_INDEXES[laneIndex]];TPiLane.high=tMsw;TPiLane.low=tLsw}// Rho pi at x = y = 0
var T0=T[0],state0=state[0];T0.high=state0.high;T0.low=state0.low;// Chi
for(var x=0;5>x;x++){for(var y=0;5>y;y++){// Shortcuts
var laneIndex=x+5*y,lane=state[laneIndex],TLane=T[laneIndex],Tx1Lane=T[(x+1)%5+5*y],Tx2Lane=T[(x+2)%5+5*y];// Mix rows
lane.high=TLane.high^~Tx1Lane.high&Tx2Lane.high;lane.low=TLane.low^~Tx1Lane.low&Tx2Lane.low}}// Iota
var lane=state[0],roundConstant=ROUND_CONSTANTS[round];lane.high^=roundConstant.high;lane.low^=roundConstant.low;;}},_doFinalize:function _doFinalize(){// Shortcuts
var data=this._data,dataWords=data.words,nBitsTotal=8*this._nDataBytes,nBitsLeft=8*data.sigBytes,blockSizeBits=32*this.blockSize;// Add padding
dataWords[nBitsLeft>>>5]|=1<<24-nBitsLeft%32;dataWords[(Math.ceil((nBitsLeft+1)/blockSizeBits)*blockSizeBits>>>5)-1]|=128;data.sigBytes=4*dataWords.length;// Hash final blocks
this._process();// Shortcuts
for(var state=this._state,outputLengthBytes=this.cfg.outputLength/8,outputLengthLanes=outputLengthBytes/8,hashWords=[],i=0;i<outputLengthLanes;i++){// Shortcuts
var lane=state[i],laneMsw=lane.high,laneLsw=lane.low;// Swap endian
laneMsw=16711935&(laneMsw<<8|laneMsw>>>24)|4278255360&(laneMsw<<24|laneMsw>>>8);laneLsw=16711935&(laneLsw<<8|laneLsw>>>24)|4278255360&(laneLsw<<24|laneLsw>>>8);// Squeeze state to retrieve hash
hashWords.push(laneLsw);hashWords.push(laneMsw)}// Return final computed hash
return new WordArray.init(hashWords,outputLengthBytes)},clone:function clone(){for(var clone=Hasher.clone.call(this),state=clone._state=this._state.slice(0),i=0;25>i;i++){state[i]=state[i].clone()}return clone}});/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */C.SHA3=Hasher._createHelper(SHA3);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */C.HmacSHA3=Hasher._createHmacHelper(SHA3)})(Math);(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,Hasher=C_lib.Hasher,C_x64=C.x64,X64Word=C_x64.Word,X64WordArray=C_x64.WordArray,C_algo=C.algo;function X64Word_create(){return X64Word.create.apply(X64Word,arguments)}// Constants
var K=[X64Word_create(1116352408,3609767458),X64Word_create(1899447441,602891725),X64Word_create(3049323471,3964484399),X64Word_create(3921009573,2173295548),X64Word_create(961987163,4081628472),X64Word_create(1508970993,3053834265),X64Word_create(2453635748,2937671579),X64Word_create(2870763221,3664609560),X64Word_create(3624381080,2734883394),X64Word_create(310598401,1164996542),X64Word_create(607225278,1323610764),X64Word_create(1426881987,3590304994),X64Word_create(1925078388,4068182383),X64Word_create(2162078206,991336113),X64Word_create(2614888103,633803317),X64Word_create(3248222580,3479774868),X64Word_create(3835390401,2666613458),X64Word_create(4022224774,944711139),X64Word_create(264347078,2341262773),X64Word_create(604807628,2007800933),X64Word_create(770255983,1495990901),X64Word_create(1249150122,1856431235),X64Word_create(1555081692,3175218132),X64Word_create(1996064986,2198950837),X64Word_create(2554220882,3999719339),X64Word_create(2821834349,766784016),X64Word_create(2952996808,2566594879),X64Word_create(3210313671,3203337956),X64Word_create(3336571891,1034457026),X64Word_create(3584528711,2466948901),X64Word_create(113926993,3758326383),X64Word_create(338241895,168717936),X64Word_create(666307205,1188179964),X64Word_create(773529912,1546045734),X64Word_create(1294757372,1522805485),X64Word_create(1396182291,2643833823),X64Word_create(1695183700,2343527390),X64Word_create(1986661051,1014477480),X64Word_create(2177026350,1206759142),X64Word_create(2456956037,344077627),X64Word_create(2730485921,1290863460),X64Word_create(2820302411,3158454273),X64Word_create(3259730800,3505952657),X64Word_create(3345764771,106217008),X64Word_create(3516065817,3606008344),X64Word_create(3600352804,1432725776),X64Word_create(4094571909,1467031594),X64Word_create(275423344,851169720),X64Word_create(430227734,3100823752),X64Word_create(506948616,1363258195),X64Word_create(659060556,3750685593),X64Word_create(883997877,3785050280),X64Word_create(958139571,3318307427),X64Word_create(1322822218,3812723403),X64Word_create(1537002063,2003034995),X64Word_create(1747873779,3602036899),X64Word_create(1955562222,1575990012),X64Word_create(2024104815,1125592928),X64Word_create(2227730452,2716904306),X64Word_create(2361852424,442776044),X64Word_create(2428436474,593698344),X64Word_create(2756734187,3733110249),X64Word_create(3204031479,2999351573),X64Word_create(3329325298,3815920427),X64Word_create(3391569614,3928383900),X64Word_create(3515267271,566280711),X64Word_create(3940187606,3454069534),X64Word_create(4118630271,4000239992),X64Word_create(116418474,1914138554),X64Word_create(174292421,2731055270),X64Word_create(289380356,3203993006),X64Word_create(460393269,320620315),X64Word_create(685471733,587496836),X64Word_create(852142971,1086792851),X64Word_create(1017036298,365543100),X64Word_create(1126000580,2618297676),X64Word_create(1288033470,3409855158),X64Word_create(1501505948,4234509866),X64Word_create(1607167915,987167468),X64Word_create(1816402316,1246189591)],W=[];// Reusable objects
(function(){for(var i=0;80>i;i++){W[i]=X64Word_create()}})();/**
	     * SHA-512 hash algorithm.
	     */var SHA512=C_algo.SHA512=Hasher.extend({_doReset:function _doReset(){this._hash=new X64WordArray.init([new X64Word.init(1779033703,4089235720),new X64Word.init(3144134277,2227873595),new X64Word.init(1013904242,4271175723),new X64Word.init(2773480762,1595750129),new X64Word.init(1359893119,2917565137),new X64Word.init(2600822924,725511199),new X64Word.init(528734635,4215389547),new X64Word.init(1541459225,327033209)])},_doProcessBlock:function _doProcessBlock(M,offset){// Shortcuts
// Rounds
for(var H=this._hash.words,H0=H[0],H1=H[1],H2=H[2],H3=H[3],H4=H[4],H5=H[5],H6=H[6],H7=H[7],H0h=H0.high,H0l=H0.low,H1h=H1.high,H1l=H1.low,H2h=H2.high,H2l=H2.low,H3h=H3.high,H3l=H3.low,H4h=H4.high,H4l=H4.low,H5h=H5.high,H5l=H5.low,H6h=H6.high,H6l=H6.low,H7h=H7.high,H7l=H7.low,ah=H0h,al=H0l,bh=H1h,bl=H1l,ch=H2h,cl=H2l,dh=H3h,dl=H3l,eh=H4h,el=H4l,fh=H5h,fl=H5l,gh=H6h,gl=H6l,hh=H7h,hl=H7l,i=0,Wi;80>i;i++){// Shortcut
Wi=W[i];// Extend message
if(16>i){var Wih=Wi.high=0|M[offset+2*i],Wil=Wi.low=0|M[offset+2*i+1]}else{// Gamma0
var gamma0x=W[i-15],gamma0xh=gamma0x.high,gamma0xl=gamma0x.low,gamma0h=(gamma0xh>>>1|gamma0xl<<31)^(gamma0xh>>>8|gamma0xl<<24)^gamma0xh>>>7,gamma0l=(gamma0xl>>>1|gamma0xh<<31)^(gamma0xl>>>8|gamma0xh<<24)^(gamma0xl>>>7|gamma0xh<<25),gamma1x=W[i-2],gamma1xh=gamma1x.high,gamma1xl=gamma1x.low,gamma1h=(gamma1xh>>>19|gamma1xl<<13)^(gamma1xh<<3|gamma1xl>>>29)^gamma1xh>>>6,gamma1l=(gamma1xl>>>19|gamma1xh<<13)^(gamma1xl<<3|gamma1xh>>>29)^(gamma1xl>>>6|gamma1xh<<26),Wi7=W[i-7],Wi7h=Wi7.high,Wi7l=Wi7.low,Wi16=W[i-16],Wi16h=Wi16.high,Wi16l=Wi16.low,Wil=gamma0l+Wi7l,Wih=gamma0h+Wi7h+(Wil>>>0<gamma0l>>>0?1:0),Wil=Wil+gamma1l,Wih=Wih+gamma1h+(Wil>>>0<gamma1l>>>0?1:0),Wil=Wil+Wi16l,Wih=Wih+Wi16h+(Wil>>>0<Wi16l>>>0?1:0);Wi.high=Wih;Wi.low=Wil}var chh=eh&fh^~eh&gh,chl=el&fl^~el&gl,majh=ah&bh^ah&ch^bh&ch,majl=al&bl^al&cl^bl&cl,sigma0h=(ah>>>28|al<<4)^(ah<<30|al>>>2)^(ah<<25|al>>>7),sigma0l=(al>>>28|ah<<4)^(al<<30|ah>>>2)^(al<<25|ah>>>7),sigma1h=(eh>>>14|el<<18)^(eh>>>18|el<<14)^(eh<<23|el>>>9),sigma1l=(el>>>14|eh<<18)^(el>>>18|eh<<14)^(el<<23|eh>>>9),Ki=K[i],Kih=Ki.high,Kil=Ki.low,t1l=hl+sigma1l,t1h=hh+sigma1h+(t1l>>>0<hl>>>0?1:0),t1l=t1l+chl,t1h=t1h+chh+(t1l>>>0<chl>>>0?1:0),t1l=t1l+Kil,t1h=t1h+Kih+(t1l>>>0<Kil>>>0?1:0),t1l=t1l+Wil,t1h=t1h+Wih+(t1l>>>0<Wil>>>0?1:0),t2l=sigma0l+majl,t2h=sigma0h+majh+(t2l>>>0<sigma0l>>>0?1:0);// Update working variables
hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;el=0|dl+t1l;eh=0|dh+t1h+(el>>>0<dl>>>0?1:0);dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;al=0|t1l+t2l;ah=0|t1h+t2h+(al>>>0<t1l>>>0?1:0)}// Intermediate hash value
H0l=H0.low=H0l+al;H0.high=H0h+ah+(H0l>>>0<al>>>0?1:0);H1l=H1.low=H1l+bl;H1.high=H1h+bh+(H1l>>>0<bl>>>0?1:0);H2l=H2.low=H2l+cl;H2.high=H2h+ch+(H2l>>>0<cl>>>0?1:0);H3l=H3.low=H3l+dl;H3.high=H3h+dh+(H3l>>>0<dl>>>0?1:0);H4l=H4.low=H4l+el;H4.high=H4h+eh+(H4l>>>0<el>>>0?1:0);H5l=H5.low=H5l+fl;H5.high=H5h+fh+(H5l>>>0<fl>>>0?1:0);H6l=H6.low=H6l+gl;H6.high=H6h+gh+(H6l>>>0<gl>>>0?1:0);H7l=H7.low=H7l+hl;H7.high=H7h+hh+(H7l>>>0<hl>>>0?1:0)},_doFinalize:function _doFinalize(){// Shortcuts
var data=this._data,dataWords=data.words,nBitsTotal=8*this._nDataBytes,nBitsLeft=8*data.sigBytes;// Add padding
dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+128>>>10<<5)+30]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+128>>>10<<5)+31]=nBitsTotal;data.sigBytes=4*dataWords.length;// Hash final blocks
this._process();// Convert hash to 32-bit word array before returning
var hash=this._hash.toX32();// Return final computed hash
return hash},clone:function clone(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone},blockSize:1024/32});/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */C.SHA512=Hasher._createHelper(SHA512);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */C.HmacSHA512=Hasher._createHmacHelper(SHA512)})();(function(){// Shortcuts
var C=CryptoJS,C_x64=C.x64,X64Word=C_x64.Word,X64WordArray=C_x64.WordArray,C_algo=C.algo,SHA512=C_algo.SHA512,SHA384=C_algo.SHA384=SHA512.extend({_doReset:function _doReset(){this._hash=new X64WordArray.init([new X64Word.init(3418070365,3238371032),new X64Word.init(1654270250,914150663),new X64Word.init(2438529370,812702999),new X64Word.init(355462360,4144912697),new X64Word.init(1731405415,4290775857),new X64Word.init(2394180231,1750603025),new X64Word.init(3675008525,1694076839),new X64Word.init(1203062813,3204075428)])},_doFinalize:function _doFinalize(){var hash=SHA512._doFinalize.call(this);hash.sigBytes-=16;return hash}});/**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */C.SHA384=SHA512._createHelper(SHA384);/**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */C.HmacSHA384=SHA512._createHmacHelper(SHA384)})();/**
	 * Cipher core components.
	 */CryptoJS.lib.Cipher||function(undefined){// Shortcuts
var C=CryptoJS,C_lib=C.lib,Base=C_lib.Base,WordArray=C_lib.WordArray,BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm,C_enc=C.enc,Utf8=C_enc.Utf8,Base64=C_enc.Base64,C_algo=C.algo,EvpKDF=C_algo.EvpKDF,Cipher=C_lib.Cipher=BufferedBlockAlgorithm.extend({/**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */cfg:Base.extend(),/**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */createEncryptor:function createEncryptor(key,cfg){return this.create(this._ENC_XFORM_MODE,key,cfg)},/**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */createDecryptor:function createDecryptor(key,cfg){return this.create(this._DEC_XFORM_MODE,key,cfg)},/**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */init:function init(xformMode,key,cfg){// Apply config defaults
this.cfg=this.cfg.extend(cfg);// Store transform mode and key
this._xformMode=xformMode;this._key=key;// Set initial values
this.reset()},/**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */reset:function reset(){// Reset data buffer
BufferedBlockAlgorithm.reset.call(this);// Perform concrete-cipher logic
this._doReset()},/**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */process:function process(dataUpdate){// Append
this._append(dataUpdate);// Process available blocks
return this._process()},/**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */finalize:function finalize(dataUpdate){// Final data update
if(dataUpdate){this._append(dataUpdate)}// Perform concrete-cipher logic
var finalProcessedData=this._doFinalize();return finalProcessedData},keySize:128/32,ivSize:128/32,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,/**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */_createHelper:function(){function selectCipherStrategy(key){if("string"==typeof key){return PasswordBasedCipher}else{return SerializableCipher}}return function(cipher){return{encrypt:function encrypt(message,key,cfg){return selectCipherStrategy(key).encrypt(cipher,message,key,cfg)},decrypt:function decrypt(ciphertext,key,cfg){return selectCipherStrategy(key).decrypt(cipher,ciphertext,key,cfg)}}}}()}),StreamCipher=C_lib.StreamCipher=Cipher.extend({_doFinalize:function _doFinalize(){// Process partial blocks
var finalProcessedBlocks=this._process(!!"flush");return finalProcessedBlocks},blockSize:1}),C_mode=C.mode={},BlockCipherMode=C_lib.BlockCipherMode=Base.extend({/**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */createEncryptor:function createEncryptor(cipher,iv){return this.Encryptor.create(cipher,iv)},/**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */createDecryptor:function createDecryptor(cipher,iv){return this.Decryptor.create(cipher,iv)},/**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */init:function init(cipher,iv){this._cipher=cipher;this._iv=iv}}),CBC=C_mode.CBC=function(){/**
	         * Abstract base CBC mode.
	         */var CBC=BlockCipherMode.extend();/**
	         * CBC encryptor.
	         */CBC.Encryptor=CBC.extend({/**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */processBlock:function processBlock(words,offset){// Shortcuts
var cipher=this._cipher,blockSize=cipher.blockSize;// XOR and encrypt
xorBlock.call(this,words,offset,blockSize);cipher.encryptBlock(words,offset);// Remember this block to use with next block
this._prevBlock=words.slice(offset,offset+blockSize)}});/**
	         * CBC decryptor.
	         */CBC.Decryptor=CBC.extend({/**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */processBlock:function processBlock(words,offset){// Shortcuts
var cipher=this._cipher,blockSize=cipher.blockSize,thisBlock=words.slice(offset,offset+blockSize);// Decrypt and XOR
cipher.decryptBlock(words,offset);xorBlock.call(this,words,offset,blockSize);// This block becomes the previous block
this._prevBlock=thisBlock}});function xorBlock(words,offset,blockSize){// Shortcut
var iv=this._iv;// Choose mixing block
if(iv){var block=iv;// Remove IV for subsequent blocks
this._iv=void 0}else{var block=this._prevBlock}// XOR blocks
for(var i=0;i<blockSize;i++){words[offset+i]^=block[i]}}return CBC}(),C_pad=C.pad={},Pkcs7=C_pad.Pkcs7={/**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */pad:function pad(data,blockSize){// Shortcut
for(var blockSizeBytes=4*blockSize,nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes,paddingWord=nPaddingBytes<<24|nPaddingBytes<<16|nPaddingBytes<<8|nPaddingBytes,paddingWords=[],i=0;i<nPaddingBytes;i+=4){paddingWords.push(paddingWord)}var padding=WordArray.create(paddingWords,nPaddingBytes);// Add padding
data.concat(padding)},/**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */unpad:function unpad(data){// Get number of padding bytes from last byte
var nPaddingBytes=255&data.words[data.sigBytes-1>>>2];// Remove padding
data.sigBytes-=nPaddingBytes}},BlockCipher=C_lib.BlockCipher=Cipher.extend({/**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */cfg:Cipher.cfg.extend({mode:CBC,padding:Pkcs7}),reset:function reset(){// Reset cipher
Cipher.reset.call(this);// Shortcuts
var cfg=this.cfg,iv=cfg.iv,mode=cfg.mode;// Reset block mode
if(this._xformMode==this._ENC_XFORM_MODE){var modeCreator=mode.createEncryptor}else/* if (this._xformMode == this._DEC_XFORM_MODE) */{var modeCreator=mode.createDecryptor;// Keep at least one block in the buffer for unpadding
this._minBufferSize=1}if(this._mode&&this._mode.__creator==modeCreator){this._mode.init(this,iv&&iv.words)}else{this._mode=modeCreator.call(mode,this,iv&&iv.words);this._mode.__creator=modeCreator}},_doProcessBlock:function _doProcessBlock(words,offset){this._mode.processBlock(words,offset)},_doFinalize:function _doFinalize(){// Shortcut
var padding=this.cfg.padding;// Finalize
if(this._xformMode==this._ENC_XFORM_MODE){// Pad data
padding.pad(this._data,this.blockSize);// Process final blocks
var finalProcessedBlocks=this._process(!!"flush")}else/* if (this._xformMode == this._DEC_XFORM_MODE) */{// Process final blocks
var finalProcessedBlocks=this._process(!!"flush");// Unpad data
padding.unpad(finalProcessedBlocks)}return finalProcessedBlocks},blockSize:128/32}),CipherParams=C_lib.CipherParams=Base.extend({/**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */init:function init(cipherParams){this.mixIn(cipherParams)},/**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */toString:function toString(formatter){return(formatter||this.formatter).stringify(this)}}),C_format=C.format={},OpenSSLFormatter=C_format.OpenSSL={/**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */stringify:function stringify(cipherParams){// Shortcuts
var ciphertext=cipherParams.ciphertext,salt=cipherParams.salt;// Format
if(salt){var wordArray=WordArray.create([1398893684,1701076831]).concat(salt).concat(ciphertext)}else{var wordArray=ciphertext}return wordArray.toString(Base64)},/**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */parse:function parse(openSSLStr){// Parse base64
var ciphertext=Base64.parse(openSSLStr),ciphertextWords=ciphertext.words;// Shortcut
// Test for salt
if(1398893684==ciphertextWords[0]&&1701076831==ciphertextWords[1]){// Extract salt
var salt=WordArray.create(ciphertextWords.slice(2,4));// Remove salt from ciphertext
ciphertextWords.splice(0,4);ciphertext.sigBytes-=16}return CipherParams.create({ciphertext:ciphertext,salt:salt})}},SerializableCipher=C_lib.SerializableCipher=Base.extend({/**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */cfg:Base.extend({format:OpenSSLFormatter}),/**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */encrypt:function encrypt(cipher,message,key,cfg){// Apply config defaults
cfg=this.cfg.extend(cfg);// Encrypt
var encryptor=cipher.createEncryptor(key,cfg),ciphertext=encryptor.finalize(message),cipherCfg=encryptor.cfg;// Create and return serializable cipher params
return CipherParams.create({ciphertext:ciphertext,key:key,iv:cipherCfg.iv,algorithm:cipher,mode:cipherCfg.mode,padding:cipherCfg.padding,blockSize:cipher.blockSize,formatter:cfg.format})},/**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */decrypt:function decrypt(cipher,ciphertext,key,cfg){// Apply config defaults
cfg=this.cfg.extend(cfg);// Convert string to CipherParams
ciphertext=this._parse(ciphertext,cfg.format);// Decrypt
var plaintext=cipher.createDecryptor(key,cfg).finalize(ciphertext.ciphertext);return plaintext},/**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */_parse:function _parse(ciphertext,format){if("string"==typeof ciphertext){return format.parse(ciphertext,this)}else{return ciphertext}}}),C_kdf=C.kdf={},OpenSSLKdf=C_kdf.OpenSSL={/**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */execute:function execute(password,keySize,ivSize,salt){// Generate random salt
if(!salt){salt=WordArray.random(64/8)}// Derive key and IV
var key=EvpKDF.create({keySize:keySize+ivSize}).compute(password,salt),iv=WordArray.create(key.words.slice(keySize),4*ivSize);// Separate key and IV
key.sigBytes=4*keySize;// Return params
return CipherParams.create({key:key,iv:iv,salt:salt})}},PasswordBasedCipher=C_lib.PasswordBasedCipher=SerializableCipher.extend({/**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */cfg:SerializableCipher.cfg.extend({kdf:OpenSSLKdf}),/**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */encrypt:function encrypt(cipher,message,password,cfg){// Apply config defaults
cfg=this.cfg.extend(cfg);// Derive key and other params
var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize);// Add IV to config
cfg.iv=derivedParams.iv;// Encrypt
var ciphertext=SerializableCipher.encrypt.call(this,cipher,message,derivedParams.key,cfg);// Mix in derived params
ciphertext.mixIn(derivedParams);return ciphertext},/**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */decrypt:function decrypt(cipher,ciphertext,password,cfg){// Apply config defaults
cfg=this.cfg.extend(cfg);// Convert string to CipherParams
ciphertext=this._parse(ciphertext,cfg.format);// Derive key and other params
var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize,ciphertext.salt);// Add IV to config
cfg.iv=derivedParams.iv;// Decrypt
var plaintext=SerializableCipher.decrypt.call(this,cipher,ciphertext,derivedParams.key,cfg);return plaintext}})}();/**
	 * Cipher Feedback block mode.
	 */CryptoJS.mode.CFB=function(){var CFB=CryptoJS.lib.BlockCipherMode.extend();CFB.Encryptor=CFB.extend({processBlock:function processBlock(words,offset){// Shortcuts
var cipher=this._cipher,blockSize=cipher.blockSize;generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);// Remember this block to use with next block
this._prevBlock=words.slice(offset,offset+blockSize)}});CFB.Decryptor=CFB.extend({processBlock:function processBlock(words,offset){// Shortcuts
var cipher=this._cipher,blockSize=cipher.blockSize,thisBlock=words.slice(offset,offset+blockSize);generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);// This block becomes the previous block
this._prevBlock=thisBlock}});function generateKeystreamAndEncrypt(words,offset,blockSize,cipher){// Shortcut
var iv=this._iv;// Generate keystream
if(iv){var keystream=iv.slice(0);// Remove IV for subsequent blocks
this._iv=void 0}else{var keystream=this._prevBlock}cipher.encryptBlock(keystream,0);// Encrypt
for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}return CFB}();/**
	 * Electronic Codebook block mode.
	 */CryptoJS.mode.ECB=function(){var ECB=CryptoJS.lib.BlockCipherMode.extend();ECB.Encryptor=ECB.extend({processBlock:function processBlock(words,offset){this._cipher.encryptBlock(words,offset)}});ECB.Decryptor=ECB.extend({processBlock:function processBlock(words,offset){this._cipher.decryptBlock(words,offset)}});return ECB}();/**
	 * ANSI X.923 padding strategy.
	 */CryptoJS.pad.AnsiX923={pad:function pad(data,blockSize){// Shortcuts
var dataSigBytes=data.sigBytes,blockSizeBytes=4*blockSize,nPaddingBytes=blockSizeBytes-dataSigBytes%blockSizeBytes,lastBytePos=dataSigBytes+nPaddingBytes-1;// Pad
data.clamp();data.words[lastBytePos>>>2]|=nPaddingBytes<<24-8*(lastBytePos%4);data.sigBytes+=nPaddingBytes},unpad:function unpad(data){// Get number of padding bytes from last byte
var nPaddingBytes=255&data.words[data.sigBytes-1>>>2];// Remove padding
data.sigBytes-=nPaddingBytes}};/**
	 * ISO 10126 padding strategy.
	 */CryptoJS.pad.Iso10126={pad:function pad(data,blockSize){// Shortcut
var blockSizeBytes=4*blockSize,nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes;// Count padding bytes
// Pad
data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes-1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes<<24],1))},unpad:function unpad(data){// Get number of padding bytes from last byte
var nPaddingBytes=255&data.words[data.sigBytes-1>>>2];// Remove padding
data.sigBytes-=nPaddingBytes}};/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */CryptoJS.pad.Iso97971={pad:function pad(data,blockSize){// Add 0x80 byte
data.concat(CryptoJS.lib.WordArray.create([2147483648],1));// Zero pad the rest
CryptoJS.pad.ZeroPadding.pad(data,blockSize)},unpad:function unpad(data){// Remove zero padding
CryptoJS.pad.ZeroPadding.unpad(data);// Remove one more byte -- the 0x80 byte
data.sigBytes--}};/**
	 * Output Feedback block mode.
	 */CryptoJS.mode.OFB=function(){var OFB=CryptoJS.lib.BlockCipherMode.extend(),Encryptor=OFB.Encryptor=OFB.extend({processBlock:function processBlock(words,offset){// Shortcuts
var cipher=this._cipher,blockSize=cipher.blockSize,iv=this._iv,keystream=this._keystream;// Generate keystream
if(iv){keystream=this._keystream=iv.slice(0);// Remove IV for subsequent blocks
this._iv=void 0}cipher.encryptBlock(keystream,0);// Encrypt
for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});OFB.Decryptor=Encryptor;return OFB}();/**
	 * A noop padding strategy.
	 */CryptoJS.pad.NoPadding={pad:function pad(){},unpad:function unpad(){}};(function(undefined){// Shortcuts
var C=CryptoJS,C_lib=C.lib,CipherParams=C_lib.CipherParams,C_enc=C.enc,Hex=C_enc.Hex,C_format=C.format,HexFormatter=C_format.Hex={/**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */stringify:function stringify(cipherParams){return cipherParams.ciphertext.toString(Hex)},/**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */parse:function parse(input){var ciphertext=Hex.parse(input);return CipherParams.create({ciphertext:ciphertext})}}})();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,BlockCipher=C_lib.BlockCipher,C_algo=C.algo,SBOX=[],INV_SBOX=[],SUB_MIX_0=[],SUB_MIX_1=[],SUB_MIX_2=[],SUB_MIX_3=[],INV_SUB_MIX_0=[],INV_SUB_MIX_1=[],INV_SUB_MIX_2=[],INV_SUB_MIX_3=[];// Compute lookup tables
(function(){// Compute double table
for(var d=[],i=0;256>i;i++){if(128>i){d[i]=i<<1}else{d[i]=283^i<<1}}// Walk GF(2^8)
for(var x=0,xi=0,i=0,sx;256>i;i++){// Compute sbox
sx=xi^xi<<1^xi<<2^xi<<3^xi<<4;sx=99^(sx>>>8^255&sx);SBOX[x]=sx;INV_SBOX[sx]=x;// Compute multiplication
var x2=d[x],x4=d[x2],x8=d[x4],t=257*d[sx]^16843008*sx;SUB_MIX_0[x]=t<<24|t>>>8;SUB_MIX_1[x]=t<<16|t>>>16;SUB_MIX_2[x]=t<<8|t>>>24;SUB_MIX_3[x]=t;// Compute inv sub bytes, inv mix columns tables
var t=16843009*x8^65537*x4^257*x2^16843008*x;INV_SUB_MIX_0[sx]=t<<24|t>>>8;INV_SUB_MIX_1[sx]=t<<16|t>>>16;INV_SUB_MIX_2[sx]=t<<8|t>>>24;INV_SUB_MIX_3[sx]=t;// Compute next counter
if(!x){x=xi=1}else{x=x2^d[d[d[x8^x2]]];xi^=d[d[xi]]}}})();// Precomputed Rcon lookup
var RCON=[0,1,2,4,8,16,32,64,128,27,54],AES=C_algo.AES=BlockCipher.extend({_doReset:function _doReset(){// Skip reset of nRounds has been set before and key did not change
if(this._nRounds&&this._keyPriorReset===this._key){return}// Shortcuts
for(var key=this._keyPriorReset=this._key,keyWords=key.words,keySize=key.sigBytes/4,nRounds=this._nRounds=keySize+6,ksRows=4*(nRounds+1),keySchedule=this._keySchedule=[],ksRow=0;ksRow<ksRows;ksRow++){if(ksRow<keySize){keySchedule[ksRow]=keyWords[ksRow]}else{var t=keySchedule[ksRow-1];if(!(ksRow%keySize)){// Rot word
t=t<<8|t>>>24;// Sub word
t=SBOX[t>>>24]<<24|SBOX[255&t>>>16]<<16|SBOX[255&t>>>8]<<8|SBOX[255&t];// Mix Rcon
t^=RCON[0|ksRow/keySize]<<24}else if(6<keySize&&4==ksRow%keySize){// Sub word
t=SBOX[t>>>24]<<24|SBOX[255&t>>>16]<<16|SBOX[255&t>>>8]<<8|SBOX[255&t]}keySchedule[ksRow]=keySchedule[ksRow-keySize]^t}}// Compute inv key schedule
for(var invKeySchedule=this._invKeySchedule=[],invKsRow=0,ksRow;invKsRow<ksRows;invKsRow++){ksRow=ksRows-invKsRow;if(invKsRow%4){var t=keySchedule[ksRow]}else{var t=keySchedule[ksRow-4]}if(4>invKsRow||4>=ksRow){invKeySchedule[invKsRow]=t}else{invKeySchedule[invKsRow]=INV_SUB_MIX_0[SBOX[t>>>24]]^INV_SUB_MIX_1[SBOX[255&t>>>16]]^INV_SUB_MIX_2[SBOX[255&t>>>8]]^INV_SUB_MIX_3[SBOX[255&t]]}}},encryptBlock:function encryptBlock(M,offset){this._doCryptBlock(M,offset,this._keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX)},decryptBlock:function decryptBlock(M,offset){// Swap 2nd and 4th rows
var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t;this._doCryptBlock(M,offset,this._invKeySchedule,INV_SUB_MIX_0,INV_SUB_MIX_1,INV_SUB_MIX_2,INV_SUB_MIX_3,INV_SBOX);// Inv swap 2nd and 4th rows
var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t},_doCryptBlock:function _doCryptBlock(M,offset,keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX){// Shortcut
// Rounds
for(var nRounds=this._nRounds,s0=M[offset]^keySchedule[0],s1=M[offset+1]^keySchedule[1],s2=M[offset+2]^keySchedule[2],s3=M[offset+3]^keySchedule[3],ksRow=4,round=1;round<nRounds;round++){// Shift rows, sub bytes, mix columns, add round key
var t0=SUB_MIX_0[s0>>>24]^SUB_MIX_1[255&s1>>>16]^SUB_MIX_2[255&s2>>>8]^SUB_MIX_3[255&s3]^keySchedule[ksRow++],t1=SUB_MIX_0[s1>>>24]^SUB_MIX_1[255&s2>>>16]^SUB_MIX_2[255&s3>>>8]^SUB_MIX_3[255&s0]^keySchedule[ksRow++],t2=SUB_MIX_0[s2>>>24]^SUB_MIX_1[255&s3>>>16]^SUB_MIX_2[255&s0>>>8]^SUB_MIX_3[255&s1]^keySchedule[ksRow++],t3=SUB_MIX_0[s3>>>24]^SUB_MIX_1[255&s0>>>16]^SUB_MIX_2[255&s1>>>8]^SUB_MIX_3[255&s2]^keySchedule[ksRow++];// Update state
s0=t0;s1=t1;s2=t2;s3=t3}// Shift rows, sub bytes, add round key
var t0=(SBOX[s0>>>24]<<24|SBOX[255&s1>>>16]<<16|SBOX[255&s2>>>8]<<8|SBOX[255&s3])^keySchedule[ksRow++],t1=(SBOX[s1>>>24]<<24|SBOX[255&s2>>>16]<<16|SBOX[255&s3>>>8]<<8|SBOX[255&s0])^keySchedule[ksRow++],t2=(SBOX[s2>>>24]<<24|SBOX[255&s3>>>16]<<16|SBOX[255&s0>>>8]<<8|SBOX[255&s1])^keySchedule[ksRow++],t3=(SBOX[s3>>>24]<<24|SBOX[255&s0>>>16]<<16|SBOX[255&s1>>>8]<<8|SBOX[255&s2])^keySchedule[ksRow++];// Set output
M[offset]=t0;M[offset+1]=t1;M[offset+2]=t2;M[offset+3]=t3},keySize:256/32});/**
	     * AES block cipher algorithm.
	     */ /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */C.AES=BlockCipher._createHelper(AES)})();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,WordArray=C_lib.WordArray,BlockCipher=C_lib.BlockCipher,C_algo=C.algo,PC1=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],PC2=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],BIT_SHIFTS=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],SBOX_P=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],SBOX_MASK=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],DES=C_algo.DES=BlockCipher.extend({_doReset:function _doReset(){// Shortcuts
for(var key=this._key,keyWords=key.words,keyBits=[],i=0,keyBitPos;56>i;i++){keyBitPos=PC1[i]-1;keyBits[i]=1&keyWords[keyBitPos>>>5]>>>31-keyBitPos%32}// Assemble 16 subkeys
for(var subKeys=this._subKeys=[],nSubKey=0;16>nSubKey;nSubKey++){// Create subkey
// Select 48 bits according to PC2
for(var subKey=subKeys[nSubKey]=[],bitShift=BIT_SHIFTS[nSubKey],i=0;24>i;i++){// Select from the left 28 key bits
subKey[0|i/6]|=keyBits[(PC2[i]-1+bitShift)%28]<<31-i%6;// Select from the right 28 key bits
subKey[4+(0|i/6)]|=keyBits[28+(PC2[i+24]-1+bitShift)%28]<<31-i%6}// Since each subkey is applied to an expanded 32-bit input,
// the subkey can be broken into 8 values scaled to 32-bits,
// which allows the key to be used without expansion
subKey[0]=subKey[0]<<1|subKey[0]>>>31;for(var i=1;7>i;i++){subKey[i]=subKey[i]>>>4*(i-1)+3}subKey[7]=subKey[7]<<5|subKey[7]>>>27}// Compute inverse subkeys
for(var invSubKeys=this._invSubKeys=[],i=0;16>i;i++){invSubKeys[i]=subKeys[15-i]}},encryptBlock:function encryptBlock(M,offset){this._doCryptBlock(M,offset,this._subKeys)},decryptBlock:function decryptBlock(M,offset){this._doCryptBlock(M,offset,this._invSubKeys)},_doCryptBlock:function _doCryptBlock(M,offset,subKeys){// Get input
this._lBlock=M[offset];this._rBlock=M[offset+1];// Initial permutation
exchangeLR.call(this,4,252645135);exchangeLR.call(this,16,65535);exchangeRL.call(this,2,858993459);exchangeRL.call(this,8,16711935);exchangeLR.call(this,1,1431655765);// Rounds
for(var round=0;16>round;round++){// Shortcuts
for(var subKey=subKeys[round],lBlock=this._lBlock,rBlock=this._rBlock,f=0,i=0;8>i;i++){f|=SBOX_P[i][((rBlock^subKey[i])&SBOX_MASK[i])>>>0]}this._lBlock=rBlock;this._rBlock=lBlock^f}// Undo swap from last round
var t=this._lBlock;this._lBlock=this._rBlock;this._rBlock=t;// Final permutation
exchangeLR.call(this,1,1431655765);exchangeRL.call(this,8,16711935);exchangeRL.call(this,2,858993459);exchangeLR.call(this,16,65535);exchangeLR.call(this,4,252645135);// Set output
M[offset]=this._lBlock;M[offset+1]=this._rBlock},keySize:64/32,ivSize:64/32,blockSize:64/32});// Swap bits across the left and right words
function exchangeLR(offset,mask){var t=(this._lBlock>>>offset^this._rBlock)&mask;this._rBlock^=t;this._lBlock^=t<<offset}function exchangeRL(offset,mask){var t=(this._rBlock>>>offset^this._lBlock)&mask;this._lBlock^=t;this._rBlock^=t<<offset}/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */C.DES=BlockCipher._createHelper(DES);/**
	     * Triple-DES block cipher algorithm.
	     */var TripleDES=C_algo.TripleDES=BlockCipher.extend({_doReset:function _doReset(){// Shortcuts
var key=this._key,keyWords=key.words;// Create DES instances
this._des1=DES.createEncryptor(WordArray.create(keyWords.slice(0,2)));this._des2=DES.createEncryptor(WordArray.create(keyWords.slice(2,4)));this._des3=DES.createEncryptor(WordArray.create(keyWords.slice(4,6)))},encryptBlock:function encryptBlock(M,offset){this._des1.encryptBlock(M,offset);this._des2.decryptBlock(M,offset);this._des3.encryptBlock(M,offset)},decryptBlock:function decryptBlock(M,offset){this._des3.decryptBlock(M,offset);this._des2.encryptBlock(M,offset);this._des1.decryptBlock(M,offset)},keySize:192/32,ivSize:64/32,blockSize:64/32});/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */C.TripleDES=BlockCipher._createHelper(TripleDES)})();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,StreamCipher=C_lib.StreamCipher,C_algo=C.algo,RC4=C_algo.RC4=StreamCipher.extend({_doReset:function _doReset(){// Shortcuts
for(var key=this._key,keyWords=key.words,keySigBytes=key.sigBytes,S=this._S=[],i=0;256>i;i++){S[i]=i}// Key setup
for(var i=0,j=0;256>i;i++){var keyByteIndex=i%keySigBytes,keyByte=255&keyWords[keyByteIndex>>>2]>>>24-8*(keyByteIndex%4);j=(j+S[i]+keyByte)%256;// Swap
var t=S[i];S[i]=S[j];S[j]=t}// Counters
this._i=this._j=0},_doProcessBlock:function _doProcessBlock(M,offset){M[offset]^=generateKeystreamWord.call(this)},keySize:256/32,ivSize:0});function generateKeystreamWord(){// Shortcuts
for(var S=this._S,i=this._i,j=this._j,keystreamWord=0,n=0;4>n;n++){i=(i+1)%256;j=(j+S[i])%256;// Swap
var t=S[i];S[i]=S[j];S[j]=t;keystreamWord|=S[(S[i]+S[j])%256]<<24-8*n}// Update counters
this._i=i;this._j=j;return keystreamWord}/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */C.RC4=StreamCipher._createHelper(RC4);/**
	     * Modified RC4 stream cipher algorithm.
	     */var RC4Drop=C_algo.RC4Drop=RC4.extend({/**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */cfg:RC4.cfg.extend({drop:192}),_doReset:function _doReset(){RC4._doReset.call(this);// Drop
for(var i=this.cfg.drop;0<i;i--){generateKeystreamWord.call(this)}}});/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */C.RC4Drop=StreamCipher._createHelper(RC4Drop)})();/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */CryptoJS.mode.CTRGladman=function(){var CTRGladman=CryptoJS.lib.BlockCipherMode.extend();function incWord(word){if(255===(255&word>>24)){//overflow
var b1=255&word>>16,b2=255&word>>8,b3=255&word;if(255===b1)// overflow b1
{b1=0;if(255===b2){b2=0;if(255===b3){b3=0}else{++b3}}else{++b2}}else{++b1}word=0;word+=b1<<16;word+=b2<<8;word+=b3}else{word+=1<<24}return word}function incCounter(counter){if(0===(counter[0]=incWord(counter[0]))){// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
counter[1]=incWord(counter[1])}return counter}var Encryptor=CTRGladman.Encryptor=CTRGladman.extend({processBlock:function processBlock(words,offset){// Shortcuts
var cipher=this._cipher,blockSize=cipher.blockSize,iv=this._iv,counter=this._counter;// Generate keystream
if(iv){counter=this._counter=iv.slice(0);// Remove IV for subsequent blocks
this._iv=void 0}incCounter(counter);var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);// Encrypt
for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTRGladman.Decryptor=Encryptor;return CTRGladman}();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,StreamCipher=C_lib.StreamCipher,C_algo=C.algo,S=[],C_=[],G=[],Rabbit=C_algo.Rabbit=StreamCipher.extend({_doReset:function _doReset(){// Shortcuts
// Swap endian
for(var K=this._key.words,iv=this.cfg.iv,i=0;4>i;i++){K[i]=16711935&(K[i]<<8|K[i]>>>24)|4278255360&(K[i]<<24|K[i]>>>8)}// Generate initial state values
var X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16],C=this._C=[K[2]<<16|K[2]>>>16,4294901760&K[0]|65535&K[1],K[3]<<16|K[3]>>>16,4294901760&K[1]|65535&K[2],K[0]<<16|K[0]>>>16,4294901760&K[2]|65535&K[3],K[1]<<16|K[1]>>>16,4294901760&K[3]|65535&K[0]];// Generate initial counter values
// Carry bit
this._b=0;// Iterate the system four times
for(var i=0;4>i;i++){nextState.call(this)}// Modify the counters
for(var i=0;8>i;i++){C[i]^=X[7&i+4]}// IV setup
if(iv){// Shortcuts
var IV=iv.words,IV_0=IV[0],IV_1=IV[1],i0=16711935&(IV_0<<8|IV_0>>>24)|4278255360&(IV_0<<24|IV_0>>>8),i2=16711935&(IV_1<<8|IV_1>>>24)|4278255360&(IV_1<<24|IV_1>>>8),i1=i0>>>16|4294901760&i2,i3=i2<<16|65535&i0;// Modify counter values
C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;// Iterate the system four times
for(var i=0;4>i;i++){nextState.call(this)}}},_doProcessBlock:function _doProcessBlock(M,offset){// Shortcut
var X=this._X;// Iterate the system
nextState.call(this);// Generate four keystream words
S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;4>i;i++){// Swap endian
S[i]=16711935&(S[i]<<8|S[i]>>>24)|4278255360&(S[i]<<24|S[i]>>>8);// Encrypt
M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});function nextState(){// Shortcuts
// Save old counter values
for(var X=this._X,C=this._C,i=0;8>i;i++){C_[i]=C[i]}// Calculate new counter values
C[0]=0|C[0]+1295307597+this._b;C[1]=0|C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0);C[2]=0|C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0);C[3]=0|C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0);C[4]=0|C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0);C[5]=0|C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0);C[6]=0|C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0);C[7]=0|C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0);this._b=C[7]>>>0<C_[7]>>>0?1:0;// Calculate the g-values
for(var i=0;8>i;i++){var gx=X[i]+C[i],ga=65535&gx,gb=gx>>>16,gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb,gl=(0|(4294901760&gx)*gx)+(0|(65535&gx)*gx);// Construct high and low argument for squaring
// High XOR low
G[i]=gh^gl}// Calculate new state values
X[0]=0|G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16);X[1]=0|G[1]+(G[0]<<8|G[0]>>>24)+G[7];X[2]=0|G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16);X[3]=0|G[3]+(G[2]<<8|G[2]>>>24)+G[1];X[4]=0|G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16);X[5]=0|G[5]+(G[4]<<8|G[4]>>>24)+G[3];X[6]=0|G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16);X[7]=0|G[7]+(G[6]<<8|G[6]>>>24)+G[5]}/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */C.Rabbit=StreamCipher._createHelper(Rabbit)})();/**
	 * Counter block mode.
	 */CryptoJS.mode.CTR=function(){var CTR=CryptoJS.lib.BlockCipherMode.extend(),Encryptor=CTR.Encryptor=CTR.extend({processBlock:function processBlock(words,offset){// Shortcuts
var cipher=this._cipher,blockSize=cipher.blockSize,iv=this._iv,counter=this._counter;// Generate keystream
if(iv){counter=this._counter=iv.slice(0);// Remove IV for subsequent blocks
this._iv=void 0}var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);// Increment counter
counter[blockSize-1]=0|counter[blockSize-1]+1;// Encrypt
for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTR.Decryptor=Encryptor;return CTR}();(function(){// Shortcuts
var C=CryptoJS,C_lib=C.lib,StreamCipher=C_lib.StreamCipher,C_algo=C.algo,S=[],C_=[],G=[],RabbitLegacy=C_algo.RabbitLegacy=StreamCipher.extend({_doReset:function _doReset(){// Shortcuts
var K=this._key.words,iv=this.cfg.iv,X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16],C=this._C=[K[2]<<16|K[2]>>>16,4294901760&K[0]|65535&K[1],K[3]<<16|K[3]>>>16,4294901760&K[1]|65535&K[2],K[0]<<16|K[0]>>>16,4294901760&K[2]|65535&K[3],K[1]<<16|K[1]>>>16,4294901760&K[3]|65535&K[0]];// Carry bit
this._b=0;// Iterate the system four times
for(var i=0;4>i;i++){nextState.call(this)}// Modify the counters
for(var i=0;8>i;i++){C[i]^=X[7&i+4]}// IV setup
if(iv){// Shortcuts
var IV=iv.words,IV_0=IV[0],IV_1=IV[1],i0=16711935&(IV_0<<8|IV_0>>>24)|4278255360&(IV_0<<24|IV_0>>>8),i2=16711935&(IV_1<<8|IV_1>>>24)|4278255360&(IV_1<<24|IV_1>>>8),i1=i0>>>16|4294901760&i2,i3=i2<<16|65535&i0;// Modify counter values
C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;// Iterate the system four times
for(var i=0;4>i;i++){nextState.call(this)}}},_doProcessBlock:function _doProcessBlock(M,offset){// Shortcut
var X=this._X;// Iterate the system
nextState.call(this);// Generate four keystream words
S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;4>i;i++){// Swap endian
S[i]=16711935&(S[i]<<8|S[i]>>>24)|4278255360&(S[i]<<24|S[i]>>>8);// Encrypt
M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});function nextState(){// Shortcuts
// Save old counter values
for(var X=this._X,C=this._C,i=0;8>i;i++){C_[i]=C[i]}// Calculate new counter values
C[0]=0|C[0]+1295307597+this._b;C[1]=0|C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0);C[2]=0|C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0);C[3]=0|C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0);C[4]=0|C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0);C[5]=0|C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0);C[6]=0|C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0);C[7]=0|C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0);this._b=C[7]>>>0<C_[7]>>>0?1:0;// Calculate the g-values
for(var i=0;8>i;i++){var gx=X[i]+C[i],ga=65535&gx,gb=gx>>>16,gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb,gl=(0|(4294901760&gx)*gx)+(0|(65535&gx)*gx);// Construct high and low argument for squaring
// High XOR low
G[i]=gh^gl}// Calculate new state values
X[0]=0|G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16);X[1]=0|G[1]+(G[0]<<8|G[0]>>>24)+G[7];X[2]=0|G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16);X[3]=0|G[3]+(G[2]<<8|G[2]>>>24)+G[1];X[4]=0|G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16);X[5]=0|G[5]+(G[4]<<8|G[4]>>>24)+G[3];X[6]=0|G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16);X[7]=0|G[7]+(G[6]<<8|G[6]>>>24)+G[5]}/**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */C.RabbitLegacy=StreamCipher._createHelper(RabbitLegacy)})();/**
	 * Zero padding strategy.
	 */CryptoJS.pad.ZeroPadding={pad:function pad(data,blockSize){// Shortcut
var blockSizeBytes=4*blockSize;// Pad
data.clamp();data.sigBytes+=blockSizeBytes-(data.sigBytes%blockSizeBytes||blockSizeBytes)},unpad:function unpad(data){// Shortcut
var dataWords=data.words,i=data.sigBytes-1;// Unpad
while(!(255&dataWords[i>>>2]>>>24-8*(i%4))){i--}data.sigBytes=i+1}};return CryptoJS});</script></dom-module></div></body></html>